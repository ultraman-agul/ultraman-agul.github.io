<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>WebDesign</title>
    <url>/2020/05/04/01Fcc/</url>
    <content><![CDATA[<h1 id="FreeCodeCamp-Projects"><a href="#FreeCodeCamp-Projects" class="headerlink" title="FreeCodeCamp-Projects"></a>FreeCodeCamp-Projects</h1><p>本文记录我在fcc中文社区刷的题，做的小项目。2020/4/1。</p>
<h2 id="Responsive-Web-Design-Projects"><a href="#Responsive-Web-Design-Projects" class="headerlink" title="Responsive Web Design Projects"></a>Responsive Web Design Projects</h2><p>响应式网页设计项目。在此之前已经学过基本的知识，一天内把前面的小练习做完，现在是时候把学到的技能付诸实践了！通过接下来的项目，fcc让我有机会实践目前所学的技能，原理和概念，HTML，CSS，可视化设计，辅助功能等。</p>
<ol>
<li>搭建致敬页</li>
<li>搭建调查表格</li>
<li>搭建产品主页</li>
<li>搭建技术文档页面</li>
<li>搭建个人作品集页面</li>
</ol>
<h3 id="致敬页"><a href="#致敬页" class="headerlink" title="致敬页"></a>致敬页</h3><p><a href="https://learn.freecodecamp.one/responsive-web-design/responsive-web-design-projects/build-a-tribute-page" target="_blank" rel="noopener">fcc题目（需求）地址</a></p>
<p><a href="https://ultraman-agul.github.io/FreeCodeCamp/ResponsiveWebDesign/TributePage.html">我制作的页面地址</a></p>
<p>这个页面制作简单，很基本的页面，但有一个地方需要注意：</p>
<p><code>img元素应相对于其父元素的宽度响应地调整大小，但不超过其原始大小。</code></p>
<p>我一开始忽略了这个需求，看错误报告也发下缩小页面后图片不能自适应，对于手机端来说更是个大问题，所以为图片添加css样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#image &#123;</span><br><span class="line">			max-width:100%;</span><br><span class="line">			height:auto; </span><br><span class="line">			margin:0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来图片可以随着拉伸页面进行自适应了，问题也就解决了。( •̀ ω •́ )y</p>
<h3 id="调查表单"><a href="#调查表单" class="headerlink" title="调查表单"></a>调查表单</h3><p><a href="https://learn.freecodecamp.one/responsive-web-design/responsive-web-design-projects/build-a-survey-form" target="_blank" rel="noopener">fcc题目（需求）地址</a></p>
<p><a href="https://ultraman-agul.github.io/FreeCodeCamp/ResponsiveWebDesign/SurveyForm.html">我制作的页面地址</a></p>
<p>给网页添加了背景图，但是发现这样会使文字看不清，想要实现背景图和颜色遮罩，我一开始想要使用伪类元素解决：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/1.png" alt=""></p>
<p>出现文字也被遮罩，所以我使用添加新标签<main></main>，添加css为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以实现。</p>
<p>但是当内容高度大于窗口高度，需要滑动滚动条时，出现问题：</p>
<p><img src="/images/2.png" alt=""></p>
<p>下方没有了遮盖，检查代码发现main标签添加了绝对定位absolute，虽然高度为100%，那是针对浏览器窗口大小所定的，并非随着body大小而改变，将 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span><br></pre></td></tr></table></figure>

<p>去掉即可 。（尽量让代码简洁，不要出现多余的代码😵）</p>
<p>制作表单，让其居中时发现form始终无法居中，分析原因是form本身只是一个表单，对页面根本没有布局的作用，因此无法居中，解决方法是在form外面嵌套div标签，给div标签添加css样式<code>text-align:center;</code>解决。</p>
<h3 id="产品登录页"><a href="#产品登录页" class="headerlink" title="产品登录页"></a>产品登录页</h3><p><a href="https://learn.freecodecamp.one/responsive-web-design/responsive-web-design-projects/build-a-product-landing-page" target="_blank" rel="noopener">题目需求页面</a></p>
<p><a href="https://ultraman-agul.github.io/FreeCodeCamp/ResponsiveWebDesign/ProductsLogin.html">我制作的网页</a></p>
<p>运用flexbox可以布局灵活的页面.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#nav-bar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体查询也是响应式布局的好方法。当视口宽度最大值小于400px时，padding:0;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.nav-link</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用iframe给网页嵌入视频，点击全屏无反应，查阅资料说不建议使用iframe，bug多，改用video标签引入后可以使用。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;video src="http://www.w3school.com.cn/i/movie.ogg" controls&gt;</span><br><span class="line">//此处可以添加多个&lt;source&gt;&lt;/source&gt;  添加多个视频格式不一样，解决浏览器兼容性问题。</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p>flexbox和媒体查询的使用较为生疏，多使用才能熟练掌握。</p>
<h3 id="技术文档"><a href="#技术文档" class="headerlink" title="技术文档"></a>技术文档</h3><p><a href="https://learn.freecodecamp.one/responsive-web-design/responsive-web-design-projects/build-a-technical-documentation-page" target="_blank" rel="noopener">题目需求页面</a></p>
<p><a href="https://ultraman-agul.github.io/FreeCodeCamp/ResponsiveWebDesign/Document.html">我制作的网页地址</a></p>
<p>设计可以滚动的侧边导航栏：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#navbar</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">290px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.uu</span> &#123;</span><br><span class="line">  <span class="comment">/*   100%则没有滚动的空间 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">88%</span>;</span><br><span class="line">  <span class="comment">/*   滚动条的设置 */</span></span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">5px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体查询</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">800px</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*   响应手机端 */</span></span><br><span class="line">  <span class="selector-id">#navbar</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#navbar</span>&#123;</span><br><span class="line">    position:absolute;   //浮在页面最上方</span><br><span class="line">    width:100%;           //视口宽度</span><br><span class="line">    <span class="selector-tag">max-height</span><span class="selector-pseudo">:270px</span>;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">blue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="个人网站"><a href="#个人网站" class="headerlink" title="个人网站"></a>个人网站</h3><p><a href="https://learn.freecodecamp.one/responsive-web-design/responsive-web-design-projects/build-a-personal-portfolio-webpage" target="_blank" rel="noopener">题目需求页面</a></p>
<p><a href="https://ultraman-agul.github.io/FreeCodeCamp/ResponsiveWebDesign/Web.html">我制作的页面</a></p>
<p>插入图片下方有缝隙</p>
<p><img src="/images/3.png" alt=""></p>
<p>添加图片样式，解决</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vertical-align</span><span class="selector-pseudo">:bottom</span>;</span><br></pre></td></tr></table></figure>

<p><strong>flex</strong>和<strong>grid</strong>是当前流行的布局方法。Grid 布局与 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p>
<p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p>
<p>我一开始使用flex布局实现下图：</p>
<p><img src="/images/4.PNG" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#flexx</span>&#123; <span class="comment">/*父盒子*/</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="attribute">justify-content</span>:space-around;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">  <span class="attribute">align-content</span>:space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#flexx</span> <span class="selector-tag">div</span>&#123; <span class="comment">/*子盒子*/</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">450px</span>;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用grid布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#usegrid</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-gap</span>:<span class="number">50px</span>;  </span><br><span class="line">  <span class="attribute">grid-template-columns</span>:<span class="built_in">repeat</span>(auto-fit,minmax(<span class="number">320px</span>,<span class="number">1</span>fr));</span><br><span class="line">  <span class="attribute">max-width</span>:<span class="number">1280px</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  margin: 0 auto; //居中。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样可以实现，更为方便。</p>
<p>在为project-title两边添加隐藏尖括号，鼠标悬停时显示时，使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.code</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.code</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导致文字位置发生移动。因为display:none;不会保留元素位置。</p>
<p>使用visibility可以解决，隐藏时保留位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.code</span>&#123;</span><br><span class="line">	<span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.code</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">	<span class="attribute">visibility</span>:visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是文字的话，可以把内容颜色设为与背景色一致，悬停时改变颜色。</p>
<p>这几个小项目难度不大，但是需要留意小细节的地方，可以学到响应式布局的方法。</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>项目笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>web项目</tag>
        <tag>静态网页</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2020/05/07/02js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><p>对象属性名带有空格时，引用必须使用中括号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mydog=&#123;</span><br><span class="line"><span class="string">"my name"</span> : <span class="string">"wangcai"</span>,</span><br><span class="line"><span class="string">"legs"</span> : <span class="number">4</span>,</span><br><span class="line"> <span class="string">"tails"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hi = mydog[<span class="string">"my name"</span>];</span><br><span class="line"><span class="keyword">var</span> feet = mydog.legs;</span><br></pre></td></tr></table></figure>

<p>当我们通过变量名访问属性的时候，不需要给变量名包裹引号。因为实际上我们使用的是变量的值，而不是变量的名称。</p>
<p>给<code>myDog</code>添加一个<code>&quot;bark&quot;</code>属性，设置它的值为狗的声音，例如：”woof”。下面代码如果对象不存在<code>bark</code>属性则新建属性赋值，已经存在则修改值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myDog.bark = <span class="string">"woof"</span>;</span><br><span class="line">或</span><br><span class="line">myDog[<span class="string">"bark"</span>] = <span class="string">"woof"</span>;</span><br></pre></td></tr></table></figure>

<p>从<code>myDog</code>中删除<code>&quot;tails&quot;</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> myDog.tails;</span><br></pre></td></tr></table></figure>

<p>先后顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phoneticLookup</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> lookup = &#123;</span><br><span class="line">  <span class="string">"alpha"</span> : <span class="string">"Adams"</span>,</span><br><span class="line">  <span class="string">"bravo"</span> : <span class="string">"Boston"</span>,</span><br><span class="line">  <span class="string">"charlie"</span> : <span class="string">"Chicago"</span>,</span><br><span class="line">  <span class="string">"delta"</span> : <span class="string">"Denver"</span>,</span><br><span class="line">  <span class="string">"echo"</span> : <span class="string">"Easy"</span>,</span><br><span class="line">  <span class="string">"foxtrot"</span> :<span class="string">"Frank"</span></span><br><span class="line">&#125;;</span><br><span class="line">result = lookup[val]; <span class="comment">//调用对象语句必须要在对象语句后面，否则无法调用</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">phoneticLookup(<span class="string">"charlie"</span>);</span><br></pre></td></tr></table></figure>

<p>有时检查一个对象属性是否存在是非常有用的，我们可以用<code>.hasOwnProperty(propname)</code>方法来检查对象是否有该属性。如果有返回<code>true</code>，反之返回<code>false</code>。</p>
<p>对象将数据以一种键-值对的形式保存。在上面的示例中，<code>&quot;artist&quot;: &quot;Daft Punk&quot;</code>是一个具有<code>&quot;artist&quot;</code>键和<code>&quot;Daft Punk&quot;</code>值的属性。</p>
<p><a href="http://www.json.org/" target="_blank" rel="noopener">JavaScript Object Notation</a> 简称<code>JSON</code>是用于存储数据的相关数据交换格式。数组中有多个 JSON 对象的时候，对象与对象之间要用逗号隔开。</p>
<p>与访问嵌套对象一样，用中括号操作符同样可以访问嵌套数组。嵌套对象和嵌套数组可以灵活使用<strong>中括号操作符[]和点操作符.</strong>进行访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() <span class="comment">//返回一个0~1的随机小数，可能为0，不可能为1</span></span><br></pre></td></tr></table></figure>

<p>生成随机整数：<br><code>Math.random()</code>生成一个随机小数。<br>把这个随机小数乘以20。<br>用<code>Math.floor()</code>向下取整 获得它最近的整数。</p>
<p>返回范围内随机整数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min  <span class="comment">//包含max和min</span></span><br></pre></td></tr></table></figure>



<p><code>parseInt()</code>函数解析一个字符串并返回一个整数。它同时可接受第二个参数，一个介于2和36之间的整数，表示字符串的基数。</p>
<p>函数调用如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">parseInt</span>(<span class="string">"11"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>参数 2 表示 “11” 使用二进制数值系统。此示例将字符串 “11” 转换为整数 3。</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6</title>
    <url>/2020/05/07/03ES6/</url>
    <content><![CDATA[<h1 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h1><p>ECMAScript 是 JavaScript 的标准化版本，它旨在统一语言语言的规范和功能。所有主流的浏览器或者 Javascript 的运行环境都支持这个规范，因此 <em>ECMAScript</em> 和 <em>JavaScript</em> 的术语是通用的。</p>
<p>在2015年，ECMAScript 发布了被称为 ECMAScript 6 (ES6) 的最新版本。在这里可以学习新版本添加的许多强大的功能，包括：</p>
<ul>
<li><p>箭头函数</p>
</li>
<li><p>类</p>
</li>
<li><p>模块</p>
</li>
<li><p><code>let</code>以及<code>const</code>的语法</p>
<p><strong>请注意</strong><br>不是所有的浏览器都支持 ES6 的功能，在浏览器支持 ES6 代码之前，如果你想要在你的项目里使用 ES6 规范，你可能需要一些转译工具将 ES6 代码转换成 ES5 的代码。</p>
</li>
</ul>
<h3 id="探索-var-和-let-关键字之间的差异"><a href="#探索-var-和-let-关键字之间的差异" class="headerlink" title="探索 var 和 let 关键字之间的差异"></a>探索 var 和 let 关键字之间的差异</h3><p>使用<code>var</code>关键字来声明变量，会出现重复声明导致变量被覆盖却不会报错的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> camper = <span class="string">'James'</span>;</span><br><span class="line"><span class="keyword">var</span> camper = <span class="string">'David'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(camper);<span class="comment">// 打印出 'David'</span></span><br></pre></td></tr></table></figure>



<p>在上面的代码中，<code>camper</code>的初始值为<code>&#39;James&#39;</code>，然后又被覆盖成了<code>&#39;David&#39;</code>。</p>
<p>在小型的应用中，你可能不会遇到这样的问题，但是当你的代码规模变得更加庞大的时候，就可能会在不经意间覆盖了之前定义的变量。</p>
<p>这样的行为不会报错，导致了 debug 非常困难。</p>
<p>在 ES6 中引入了新的关键字<code>let</code>来解决<code>var</code>关键字带来的潜在问题。</p>
<p>如果你在上面的代码中，使用了<code>let</code>关键字来代替<code>var</code>关键字，结果会是一个报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> camper = <span class="string">'James'</span>;</span><br><span class="line"><span class="keyword">let</span> camper = <span class="string">'David'</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<p>你可以在浏览器的控制台里看见这个错误。</p>
<p><strong>与<code>var</code>不同的是，当使用<code>let</code>的时候，同一名字的变量只能被声明一次。</strong></p>
<p>请注意<code>&quot;use strict&quot;</code>。这代表着开启了严格模式，用于检测常见的代码错误以及”不安全”的行为，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// x 没有声明导致了报错</span></span><br></pre></td></tr></table></figure>



<blockquote>
</blockquote>
<h3 id="比较-var-和-let-关键字的作用域"><a href="#比较-var-和-let-关键字的作用域" class="headerlink" title="比较 var 和 let 关键字的作用域"></a>比较 var 和 let 关键字的作用域</h3><p>当你使用<code>var</code>关键字来声明一个变量的时候，这个变量会被声明成全局变量，或是函数内的局部变量。</p>
<p><code>let</code>关键字的作用类似，但会有一些额外的特性。如果你在代码块、语句或表达式中使用关键字<code>let</code>声明变量，这个变量的作用域就被限制在当前的代码块，语句或表达式之中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> printNumTwo;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) &#123;</span><br><span class="line">    printNumTwo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(printNumTwo());</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// 返回 "没有定义 i 变量"</span></span><br></pre></td></tr></table></figure>



<h3 id="用-const-关键字声明只读变量"><a href="#用-const-关键字声明只读变量" class="headerlink" title="用 const 关键字声明只读变量"></a>用 const 关键字声明只读变量</h3><p><code>let</code>并不是唯一的新的声明变量的方式。在 ES6里面，你还可以使用<code>const</code>关键字来声明变量。</p>
<p><code>const</code>拥有<code>let</code>的所有优点，所不同的是，通过<code>const</code>声明的变量是只读的。这意味着通过<code>const</code>声明的变量只能被赋值一次，而不能被再次赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">const</span> FAV_PET = <span class="string">"Cats"</span>;</span><br><span class="line">FAV_PET = <span class="string">"Dogs"</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<p>可以看见，尝试给通过<code>const</code>声明的变量再次赋值会报错。你应该使用<code>const</code>关键字来对所有不打算再次赋值的变量进行声明。这有助于你避免给一个常量进行额外的再次赋值。一个最佳实践是对所有常量的命名采用全大写字母，并在单词之间使用下划线进行分隔。</p>
<p><strong>当变量将会改变的时候使用<code>let</code>关键字，当变量要保持常量的时候使用<code>const</code>关键字。</strong>同时，对使用<code>const</code>声明的变量名中的字母应该都是大写的。</p>
<p>在现代的 JavaScript 里，<code>const</code>声明有很多用法。</p>
<p>一些开发者倾向默认使用<code>const</code>来声明所有变量，但如果它们打算在后续的代码中修改某个值，那在声明的时候就会用<code>let</code>。</p>
<p>然而，你要注意，对象（包括数组和函数）在使用<code>const</code>声明的时候依然是可变的。使用<code>const</code>来声明只会保证它的标识不会被重新赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> s = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 试图给 const 变量赋值，报错</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">45</span>; <span class="comment">// 与用 var 或 let 声明的数组一样，这个操作也会成功</span></span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// 返回 [5, 6, 45]</span></span><br></pre></td></tr></table></figure>



<p>从以上代码看出，你可以改变<code>[5, 6, 7]</code>自身，所以<code>s</code>变量指向了改变后的数组<code>[5, 6, 45]</code>。和所有数组一样，数组<code>s</code>中的数组元素是可以被改变的，但是因为使用了<code>const</code>关键字，你不能使用赋值操作符将变量标识<code>s</code>指向另外一个数组。</p>
<h3 id="防止对象改变"><a href="#防止对象改变" class="headerlink" title="防止对象改变"></a>防止对象改变</h3><p><code>const</code>声明并不会真的保护你的数据不被改变。为了确保数据不被改变，JavaScript 提供了一个函数<code>Object.freeze</code>来防止数据改变。</p>
<p>当一个对象被冻结的时候，你不能再对它的属性再进行增、删、改的操作。任何试图改变对象的操作都会被阻止，却不会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> name:<span class="string">"FreeCodeCamp"</span>,</span><br><span class="line"> review:<span class="string">"Awesome"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.review = <span class="string">"bad"</span>; <span class="comment">// obj 对象被冻结了，这个操作会被忽略</span></span><br><span class="line">obj.newProp = <span class="string">"Test"</span>; <span class="comment">// 也会被忽略，不允许数据改变</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123; name: "FreeCodeCamp", review:"Awesome"&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="使用箭头函数编写简洁的匿名函数"><a href="#使用箭头函数编写简洁的匿名函数" class="headerlink" title="使用箭头函数编写简洁的匿名函数"></a>使用箭头函数编写简洁的匿名函数</h3><p>在 JavaScript 里，我们会经常遇到不需要给函数命名的情况，尤其是在需要将一个函数作为参数传给另外一个函数的时候。这时，我们会创建匿名函数。因为这些函数不会在其他地方复用，所以我们不需要给它们命名。</p>
<p>这种情况下，我们通常会使用以下语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> myVar = <span class="string">"value"</span>;</span><br><span class="line"> <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ES6 提供了其他写匿名函数的方式的语法糖。你可以使用箭头函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> myVar = <span class="string">"value"</span>;</span><br><span class="line"> <span class="keyword">return</span> myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当不需要函数体，只返回一个值的时候，箭头函数允许你省略<code>return</code>关键字和外面的大括号。这样就可以将一个简单的函数简化成一个单行语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc= <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"value"</span></span><br></pre></td></tr></table></figure>



<p>这段代码仍然会返回<code>value</code>。</p>
<h3 id="带参数的箭头函数"><a href="#带参数的箭头函数" class="headerlink" title="带参数的箭头函数"></a>带参数的箭头函数</h3><p>和一般的函数一样，可以给箭头函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 给传入的数值乘以 2 并返回结果</span></span><br><span class="line"><span class="keyword">const</span> doubler = <span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>同样可以给箭头函数传递多个参数。</p>
<h3 id="编写高阶箭头函数"><a href="#编写高阶箭头函数" class="headerlink" title="编写高阶箭头函数"></a>编写高阶箭头函数</h3><p>箭头函数在类似<code>map()</code>，<code>filter()</code>，<code>reduce()</code>等需要其他函数作为参数来处理数据的高阶函数里会很好用。</p>
<p>阅读以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FBPosts.filter(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> post.thumbnail !== <span class="literal">null</span> &amp;&amp; post.shares &gt; <span class="number">100</span> &amp;&amp; post.likes &gt; <span class="number">500</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>我们写下了<code>filter</code>函数，现在用箭头函数来写同样的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FBPosts.filter(<span class="function">(<span class="params">post</span>) =&gt;</span> post.thumbnail !== <span class="literal">null</span> &amp;&amp; post.shares &gt; <span class="number">100</span> &amp;&amp; post.likes &gt; <span class="number">500</span>)</span><br></pre></td></tr></table></figure>



<p>这段代码完成了同样的任务，却变得更加简短易懂。</p>
<p>三个常用函数。</p>
<p><strong><code>filter()</code></strong>方法<strong>创建一个新数组，</strong>其中所有元素都<strong>通过</strong>了由提供的功能实现的测试。</p>
<p><strong><code>map()</code></strong>方法<strong>创建一个新数组，其中</strong>填充了在调用数组中<strong>每个元素上调用</strong>提供的函数的<strong>结果</strong>。</p>
<p><strong><code>reduce()</code></strong>方法在数组的每个元素上执行<strong>reducer</strong>函数（由您提供），从而产生<strong>单个输出值</strong>。</p>
<h3 id="设置函数的默认参数"><a href="#设置函数的默认参数" class="headerlink" title="设置函数的默认参数"></a>设置函数的默认参数</h3><p>ES6 里允许给函数传入默认参数，来构建更加灵活的函数。</p>
<p>请看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">name = <span class="string">"Anonymous"</span></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(greeting(<span class="string">"John"</span>)); <span class="comment">// Hello John</span></span><br><span class="line"><span class="built_in">console</span>.log(greeting()); <span class="comment">// Hello Anonymous</span></span><br></pre></td></tr></table></figure>

<p>默认参数会在参数没有被指定（值为 undefined ）的时候起作用。在上面的例子中，参数<code>name</code>会在没有得到新的值的时候，默认使用值 “Anonymous”。还可以给多个参数赋予默认值</p>
<h3 id="将-rest-操作符与函数参数一起使用"><a href="#将-rest-操作符与函数参数一起使用" class="headerlink" title="将 rest 操作符与函数参数一起使用"></a>将 rest 操作符与函数参数一起使用</h3><p>ES6 推出了用于函数参数的 rest 操作符帮助我们创建更加灵活的函数。在<code>rest</code>操作符的帮助下，你可以创建有一个变量来接受多个参数的函数。这些参数被储存在一个可以在函数内部读取的数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howMany</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"You have passed "</span> + args.length + <span class="string">" arguments."</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(howMany(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 输出：You have passed 3 arguments.</span></span><br></pre></td></tr></table></figure>

<p><code>rest</code>操作符可以避免查看<code>args</code>数组的需求，并且允许我们在参数数组上使用<code>map()</code>,<code>filter()</code>,和<code>reduce()</code></p>
<h3 id="使用-spread-运算符展开数组项"><a href="#使用-spread-运算符展开数组项" class="headerlink" title="使用 spread 运算符展开数组项"></a>使用 spread 运算符展开数组项</h3><p>ES6 允许我们使用 展开操作符 来展开数组，以及需要多个参数或元素的表达式。</p>
<p>下面的 ES5 代码使用了<code>apply()</code>来计算数组的最大值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">var</span> maximus = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr); <span class="comment">// 返回 89</span></span><br></pre></td></tr></table></figure>



<p>我们必须使用<code>Math.max.apply(null,arr)</code>，是因为直接调用<code>Math.max(arr)</code>会返回<code>NaN</code>。<code>Math.max()</code>函数需要传入的是一系列由逗号分隔的参数，而不是一个数组。</p>
<p>展开操作符可以提升代码的可读性，这对后续的代码维护是有积极作用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">6</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">45</span>];</span><br><span class="line"><span class="keyword">const</span> maximus = <span class="built_in">Math</span>.max(...arr); <span class="comment">// 返回 89</span></span><br></pre></td></tr></table></figure>



<p><code>...arr</code>返回了一个“打开”的数组。或者说它 <em>展开</em> 了数组。// …arr = 1,2,5     arr = [1,2,5] </p>
<p>然而，展开操作符<strong>只能够在函数的参数中，或者数组之中</strong>使用。下面的代码将会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spreaded = ...arr; <span class="comment">// 将会发生语法错误</span></span><br></pre></td></tr></table></figure>



<h3 id="使用解构赋值从对象中分配变量"><a href="#使用解构赋值从对象中分配变量" class="headerlink" title="使用解构赋值从对象中分配变量"></a>使用解构赋值从对象中分配变量</h3><p>对于对象，我们也可以做同样的操作。解构赋值 就是可以从对象中直接获取对应值的语法。</p>
<p>看看以下 ES5 的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> voxel = &#123;<span class="attr">x</span>: <span class="number">3.6</span>, <span class="attr">y</span>: <span class="number">7.4</span>, <span class="attr">z</span>: <span class="number">6.54</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> x = voxel.x; <span class="comment">// x = 3.6</span></span><br><span class="line"><span class="keyword">var</span> y = voxel.y; <span class="comment">// y = 7.4</span></span><br><span class="line"><span class="keyword">var</span> z = voxel.z; <span class="comment">// z = 6.54</span></span><br></pre></td></tr></table></figure>



<p>使用 ES6 的解构语法可以完成同样的赋值语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; x, y, z &#125; = voxel; <span class="comment">// x = 3.6, y = 7.4, z = 6.54</span></span><br></pre></td></tr></table></figure>



<p>如果你想将<code>voxel.x</code>,<code>voxel.y</code>,<code>voxel.z</code>的值分别赋给<code>a</code>,<code>b</code>,<code>c</code>，可以用以下这种很棒的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">x</span> : a, <span class="attr">y</span> : b, <span class="attr">z</span> : c &#125; = voxel; <span class="comment">// a = 3.6, b = 7.4, c = 6.54</span></span><br></pre></td></tr></table></figure>



<p>可以这样理解：“将<code>x</code>地址中的值拷贝到<code>a</code>当中去。”，等等。</p>
<h3 id="使用解构赋值从嵌套对象中分配变量"><a href="#使用解构赋值从嵌套对象中分配变量" class="headerlink" title="使用解构赋值从嵌套对象中分配变量"></a>使用解构赋值从嵌套对象中分配变量</h3><p>可以将 <em>嵌套的对象</em>解构到变量中。</p>
<p>请看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line"> start: &#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span>&#125;,</span><br><span class="line"> end: &#123; <span class="attr">x</span>: <span class="number">6</span>, <span class="attr">y</span>: <span class="number">-9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">start</span> : &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125;&#125; = a;</span><br><span class="line"><span class="built_in">console</span>.log(startX, startY); <span class="comment">// 5, 6</span></span><br></pre></td></tr></table></figure>



<p>在上面的例子里，<code>a.start</code>将值赋给了变量<code>start</code>，<code>start</code>同样也是个对象。</p>
<h3 id="使用解构赋值从数组中分配变量"><a href="#使用解构赋值从数组中分配变量" class="headerlink" title="使用解构赋值从数组中分配变量"></a>使用解构赋值从数组中分配变量</h3><p>解构数组可以如同解构对象一样简单。</p>
<p>与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。所以，你不能选择哪个元素来给变量赋值。</p>
<p>而对数组进行解构却可以让我们做到这一点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>



<p>变量<code>a</code>以及<code>b</code>分别被数组的第一、第二个元素赋值。</p>
<p>我们甚至能在数组解构中使用逗号分隔符，来获取任意一个想要的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1, 2, 5</span></span><br></pre></td></tr></table></figure>



<h3 id="使用解构赋值配合-rest-操作符来重新分配数组元素"><a href="#使用解构赋值配合-rest-操作符来重新分配数组元素" class="headerlink" title="使用解构赋值配合 rest 操作符来重新分配数组元素"></a>使用解构赋值配合 rest 操作符来重新分配数组元素</h3><p>在解构数组的某些情况下，我们可能希望将剩下的元素放进另一个数组里面。</p>
<p>以下代码的结果与使用<code>Array.prototype.slice()</code>相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ...arr] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [3, 4, 5, 7]</span></span><br></pre></td></tr></table></figure>

<p>变量<code>a</code>与<code>b</code>分别获取了数组的前两个元素的值。之后，因为<code>rest</code>操作符的存在，<code>arr</code>获取了原数组剩余的元素的值，并构成了一个新的数组。</p>
<h3 id="使用解构赋值将对象作为函数的参数传递"><a href="#使用解构赋值将对象作为函数的参数传递" class="headerlink" title="使用解构赋值将对象作为函数的参数传递"></a>使用解构赋值将对象作为函数的参数传递</h3><p>可以在函数的参数里直接解构对象。</p>
<p>请看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">profileData</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line"><span class="comment">// 对这些变量执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的操作解构了传给函数的对象。这样的操作也可以直接在参数里完成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/* 对这些参数执行某些操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传对象过来，直接解构</p>
</blockquote>
<p>这样的操作去除了多余的代码，使代码更加整洁。</p>
<p>这样做还有个额外的好处：函数不需要再去操作整个对象，而仅仅是操作复制到函数作用域内部的参数。</p>
<h3 id="使用模板字面量创建字符串"><a href="#使用模板字面量创建字符串" class="headerlink" title="使用模板字面量创建字符串"></a>使用模板字面量创建字符串</h3><p>模板字符串是 ES6 的另外一项新的功能。这是一种可以轻松构建复杂字符串的方法。</p>
<p>请看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">const</span> person = &#123;</span><br><span class="line"> name: <span class="string">"Zodiac Hasbro"</span>,</span><br><span class="line"> age: <span class="number">56</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// string interpolation</span></span><br><span class="line"> <span class="keyword">const</span> greeting = <span class="string">`Hello, my name is <span class="subst">$&#123;person.name&#125;</span>!</span></span><br><span class="line"><span class="string"> I am <span class="subst">$&#123;person.age&#125;</span> years old.`</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(greeting); <span class="comment">// 打印出</span></span><br><span class="line"> <span class="comment">// Hello, my name is Zodiac Hasbro!</span></span><br><span class="line"> <span class="comment">// I am 56 years old.</span></span><br></pre></td></tr></table></figure>

<p>这段代码有许多的不同：</p>
<p>首先，上面使用的<code>${variable}</code>语法是一个占位符。这样一来，你将不再需要使用<code>+</code>运算符来连接字符串。当需要在字符串里增加变量的时候，你只需要在变量的外面括上<code>${</code>和<code>}</code>，并将其放在字符串里就可以了。</p>
<p>其次，在例子使用了反引号，而不是引号，将字符串括了起来，并且这个字符串可以换行。</p>
<p>这个新的方式使你可以更灵活的创建复杂的字符串。</p>
<h3 id="使用简单字段编写简洁的对象字面量声明"><a href="#使用简单字段编写简洁的对象字面量声明" class="headerlink" title="使用简单字段编写简洁的对象字面量声明"></a>使用简单字段编写简洁的对象字面量声明</h3><p>ES6 添加了一些很棒的功能，以便于更方便地定义对象。</p>
<p>请看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getMousePosition = <span class="function">(<span class="params">x, y</span>) =&gt;</span> (&#123;</span><br><span class="line">x: x,</span><br><span class="line">y: y</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>getMousePosition</code>是一个返回了拥有2个属性的对象的简单函数。</p>
<p>ES6 提供了一个语法糖，消除了类似<code>x: x</code>这种冗余的写法.你可以仅仅只写一次<code>x，解释器会自动将其转换成x: x。</code></p>
<p>下面是使用这种语法重写的同样的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getMousePosition = <span class="function">(<span class="params">x, y</span>) =&gt;</span> (&#123; x, y &#125;);</span><br></pre></td></tr></table></figure>



<h3 id="用-ES6-编写简洁的函数声明"><a href="#用-ES6-编写简洁的函数声明" class="headerlink" title="用 ES6 编写简洁的函数声明"></a>用 ES6 编写简洁的函数声明</h3><p>在 ES5 中，当我们需要在对象中定义一个函数的时候，我们必须如下面这般使用<code>function</code>关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name: <span class="string">"Taylor"</span>,</span><br><span class="line">sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在 ES6 语法的对象中定义函数的时候，你可以完全删除<code>function</code>关键字和冒号。请看以下例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name: <span class="string">"Taylor"</span>,</span><br><span class="line">sayHello() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="使用-class-语法定义构造函数"><a href="#使用-class-语法定义构造函数" class="headerlink" title="使用 class 语法定义构造函数"></a>使用 class 语法定义构造函数</h3><p>ES6 提供了一个新的创建对象的语法，使用关键字<code>class</code>。</p>
<p>值得注意的是，<code>class</code>只是一个语法糖，它并不像 Java、Python 或者 Ruby 这一类的语言一样，严格履行了面向对象的开发规范。</p>
<p>在 ES5 里面，我们通常会定义一个构造函数，然后使用 <code>new</code>关键字来实例化一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SpaceShuttle = <span class="function"><span class="keyword">function</span>(<span class="params">targetPlanet</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.targetPlanet = targetPlanet;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">'Jupiter'</span>);</span><br></pre></td></tr></table></figure>

<p><code>class</code>的语法只是简单地替换了构造函数的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShuttle</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(targetPlanet)&#123;</span><br><span class="line"><span class="keyword">this</span>.targetPlanet = targetPlanet;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">'Jupiter'</span>);</span><br></pre></td></tr></table></figure>



<p>注意<code>class</code>关键字声明了一个新的函数，并在其中添加了一个会在使用<code>new</code>关键字创建新对象时调用的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClass</span>(<span class="params"></span>) </span>&#123;<span class="comment">//函数</span></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span></span>&#123;  <span class="comment">//类</span></span><br><span class="line">  <span class="keyword">constructor</span>(vagetable)&#123;   <span class="comment">//对象</span></span><br><span class="line">    name = vagetable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> Vegetable;  <span class="comment">//返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Vegetable = makeClass(); </span><br><span class="line"><span class="keyword">const</span> carrot = <span class="keyword">new</span> Vegetable(<span class="string">'carrot'</span>); <span class="comment">//调用构造方法创建对象</span></span><br><span class="line"><span class="built_in">console</span>.log(carrot.name); <span class="comment">//应该显示 'carrot'</span></span><br></pre></td></tr></table></figure>



<h3 id="使用-getter-和-setter-来控制对象的访问"><a href="#使用-getter-和-setter-来控制对象的访问" class="headerlink" title="使用 getter 和 setter 来控制对象的访问"></a>使用 getter 和 setter 来控制对象的访问</h3><p>可以从对象中获得一个值，也可以给对象的属性赋值。</p>
<p>这些通常行为被称为 getters 以及 setters。</p>
<p>Getter 函数的作用是可以让返回一个对象私有变量的值给用户，而不需要直接去访问私有变量。</p>
<p>Setter 函数的作用是可以基于传进的参数来修改对象中私有变量的值。这些修改可以是计算，或者是直接替换之前的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(author) &#123;</span><br><span class="line">  <span class="keyword">this</span>._author = author;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// getter</span></span><br><span class="line"> <span class="keyword">get</span> writer()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._author;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// setter</span></span><br><span class="line"> <span class="keyword">set</span> writer(updatedAuthor)&#123;</span><br><span class="line">  <span class="keyword">this</span>._author = updatedAuthor;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lol = <span class="keyword">new</span> Book(<span class="string">'anonymous'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer); <span class="comment">// anonymous</span></span><br><span class="line">lol.writer = <span class="string">'wut'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lol.writer); <span class="comment">// wut</span></span><br></pre></td></tr></table></figure>



<p>注意我们调用 getter 和 setter 的语法，它们看起来并不像一个函数调用。</p>
<p>Getter 和 Setter 非常重要，因为它们隐藏了内部的实现细节。</p>
<h3 id="了解-import-和-require-之间的差异"><a href="#了解-import-和-require-之间的差异" class="headerlink" title="了解 import 和 require 之间的差异"></a>了解 import 和 require 之间的差异</h3><p>在过去，我们会使用<code>require()</code>函数来从外部文件或模块中引入函数或者代码。这时候会遇到一个问题：有些文件或者模块会特别大，但你却往往只需要引入其中的一些核心代码。</p>
<p>ES6 给我们提供了<code>import</code>这个便利的工具。通过它，我们能够从外部的文件或者模块中选择我们需要的部分进行引入，从而节约载入的时间和内存空间。</p>
<p>请看下面的例子：想象<code>math_array_functions</code>拥有大概20个函数，但是我只需要<code>countItems</code>这一个函数在我当前的文件里。使用老的<code>require()</code>方式会强制我引入所有20个函数。而使用新的<code>import</code>语法，我可以只引入需要的那个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; countItems &#125; <span class="keyword">from</span> <span class="string">"math_array_functions"</span></span><br></pre></td></tr></table></figure>

<p>下面是对于上面代码的语义描述：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="function"><span class="keyword">function</span> &#125; <span class="title">from</span> "<span class="title">file_path_goes_here</span>"</span></span><br><span class="line"><span class="function">// 我们还可以用同样的方式来引入变量！</span></span><br></pre></td></tr></table></figure>



<p>对<code>import</code>的使用，有许多的写法，但是上面的例子是最常用的写法。</p>
<p><strong>注意</strong><br>在大括号里的函数名的两侧加上空格是一个最佳实践——这可以帮助我们轻松的阅读<code>import</code>语句。</p>
<p><strong>注意</strong><br>本节课中进行的是一个非浏览器操作。<code>import</code>以及与其相关的在后面课程中的语句，是无法直接在浏览器上运行的。但是，我们可以通过一些工具来使它可以在浏览器中运行。</p>
<p><strong>注意</strong><br>在许多的例子中，在文件的路径前会加上<code>./</code>；否则， node.js 会先尝试去<code>node_modules</code>目录中寻找依赖项。</p>
<h3 id="用-export-来重用代码块"><a href="#用-export-来重用代码块" class="headerlink" title="用 export 来重用代码块"></a>用 export 来重用代码块</h3><p>关于<code>import</code>语句是如何从大文件中引入其中的部分代码的。但是，为了让其正常的工作，我们还必须了解一个与之相关的语句，叫做<code>export</code>。当我们想要一些代码——函数或者变量——在其他文件中使用，我们必须将它们导出来供其他文件导入。和<code>import</code>一样，<code>export</code>也是一个非浏览器的功能。</p>
<p>下面的例子阐述了如何进行一个命名导出。通过这样，我们可以使用上节课学习的<code>import</code>语法，将导出的代码导入到其他的文件中去。请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> capitalizeString = <span class="function">(<span class="params">string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">export</span> &#123; capitalizeString &#125; <span class="comment">//如何导出函数。</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">"bar"</span>; <span class="comment">//如何导出变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外，如果你想要将你所有的`export`语句打包成一行，你可以像下面这个例子一样实现：</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> capitalizeString = <span class="function">(<span class="params">string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> foo = <span class="string">"bar"</span>;</span><br><span class="line"> <span class="keyword">export</span> &#123; capitalizeString, foo &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种方式都是非常棒的实践。</span></span><br></pre></td></tr></table></figure>



<h3 id="用-从文件中导入所有内容"><a href="#用-从文件中导入所有内容" class="headerlink" title="用 * 从文件中导入所有内容"></a>用 * 从文件中导入所有内容</h3><p>们还可以用<code>import</code>语法从文件中导入所有的内容。</p>
<p>下面是一个从同目录下的<code>&quot;math_functions&quot;</code>文件中导入所有内容的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myMathModule <span class="keyword">from</span> <span class="string">"math_functions"</span>;</span><br><span class="line">myMathModule.add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">myMathModule.subtract(<span class="number">5</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>可以在<code>import * as</code>之后添加任意的名称。这个方法接收到的值是一个对象，你可以使用<strong>点表示法</strong>来获取对象里具体的值。</p>
<h3 id="export-default-默认导出"><a href="#export-default-默认导出" class="headerlink" title="export default 默认导出"></a>export default 默认导出</h3><p>默认导出的<code>export</code>的语法。在文件中只有一个值需要导出的时候，你通常会使用这种语法。它也常常用于给文件或者模块创建返回值。</p>
<p>下面是一个简单的<code>export default</code>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="导入一个默认的导出"><a href="#导入一个默认的导出" class="headerlink" title="导入一个默认的导出"></a>导入一个默认的导出</h3><p>在上一个挑战里，你学会了<code>export default</code>的用法。还有一个重要的点，你可能需要另外一种<code>import</code>的语法来导入默认导出。</p>
<p>在下面的例子里有一个<code>add</code>函数, 它在<code>&quot;math_functions&quot;</code>文件里默认被导出。让我们看看来如何导入它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">"math_functions"</span>;</span><br><span class="line">add(<span class="number">5</span>,<span class="number">4</span>); <span class="comment">//将会返回 9</span></span><br></pre></td></tr></table></figure>



<p>这个语法只有一处不同的地方 —— 被导入的<code>add</code>值，并没有被花括号<code>{}</code>所包围。与导出值的方法不同，导入默认导出的写法仅仅只是简单的将变量名写在<code>import</code>之后。</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>ECMA标准</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/05/07/04%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>正则表达式是表示搜索模式的特殊字符串。也被称为“regex”或“regexp”，它们可以帮助程序员匹配、搜索和替换文本。由于一些字符具有特殊的含义，正则表达式可能会显得晦涩难懂。我们的目标是将这些符号和文本组合成一个你想要的匹配模式，但这只是你想要的。本节将介绍字符、一些快捷方式以及编写正则表达式的常用用法。</p>
<h3 id="使用测试方法"><a href="#使用测试方法" class="headerlink" title="使用测试方法"></a>使用测试方法</h3><p>在编程语言中，正则表达式用于匹配指定的字符串。通过正则表达式创建匹配模式（规则）可以帮你完成指定匹配。</p>
<p>如果你想要在字符串<code>&quot;The dog chased the cat&quot;</code>中匹配到<code>&quot;the&quot;</code>这个单词，你可以使用如下正则表达式：<code>/the/</code>。注意，正则表达式中不需要引号。</p>
<p>JavaScript 中有多种使用正则表达式的方法。测试正则表达式的一种方法是使用<code>.test()</code>方法。<code>.test()</code>方法会把你编写的正则表达式应用到一个字符串（即括号内的内容），如果你的匹配模式成功匹配到字符，则返回<code>true</code>，反之，返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testStr = <span class="string">"freeCodeCamp"</span>;</span><br><span class="line"><span class="keyword">let</span> testRegex = <span class="regexp">/Code/</span>;</span><br><span class="line">testRegex.test(testStr);</span><br><span class="line"><span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在字符串中搜寻<code>&quot;Kevin&quot;</code>的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testStr = <span class="string">"Hello, my name is Kevin."</span>;</span><br><span class="line"><span class="keyword">let</span> testRegex = <span class="regexp">/Kevin/</span>;</span><br><span class="line">testRegex.test(testStr);</span><br><span class="line"><span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>

<p>任何其他形式的<code>&quot;Kevin&quot;</code>都不会被匹配。例如，正则表达式<code>/Kevin/</code>不会匹配<code>&quot;kevin&quot;</code>或者<code>&quot;KEVIN&quot;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrongRegex = <span class="regexp">/kevin/</span>;</span><br><span class="line">wrongRegex.test(testStr);</span><br><span class="line"><span class="comment">// Returns false</span></span><br></pre></td></tr></table></figure>



<h3 id="多种模式匹配文字字符串"><a href="#多种模式匹配文字字符串" class="headerlink" title="多种模式匹配文字字符串 |"></a>多种模式匹配文字字符串 |</h3><p>使用正则表达式<code>/coding/</code>，你可以在其他字符串中查找<code>&quot;coding&quot;</code>。</p>
<p>这对于搜寻单个字符串非常有用，但仅限于一种匹配模式。你可以使用<code>|</code>操作符来匹配多个规则。</p>
<p>此操作符匹配在它之前或之后的匹配模式。例如，如果你想匹配<code>&quot;yes&quot;</code>或<code>&quot;no&quot;</code>，你需要的正则表达式是<code>/yes|no/</code>。</p>
<p>你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。这些匹配模式将包含更多的<code>|</code>操作符来分隔它们，比如<code>/yes|no|maybe/</code>。</p>
<h3 id="忽略大小写-i"><a href="#忽略大小写-i" class="headerlink" title="忽略大小写 i"></a>忽略大小写 i</h3><p>到目前为止，你已经了解了如何用正则表达式来执行字符串的文字匹配。但有时候，你可能也想匹配不同的英文字母大小写。</p>
<p>大小写（或者字母大小写）是大写字母和小写字母的区别。大写字母的例子有<code>&quot;A&quot;</code>、<code>&quot;B&quot;</code>和<code>&quot;C&quot;</code>。小写字母的例子有<code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>和<code>&quot;c&quot;</code>。</p>
<p>你可以使用标志（flag）来匹配这两种情况。标志有很多，不过这里我们只关注忽略大小写的标志——<strong><code>i</code></strong>。你可以通过将它附加到正则表达式之后来使用它。这里给出使用该标志的一个实例<code>/ignorecase/i</code>。这个字符串可以匹配字符串<code>&quot;ignorecase&quot;</code>、<code>&quot;igNoreCase&quot;</code>和<code>&quot;IgnoreCase&quot;</code>。</p>
<h3 id="提取匹配项-match"><a href="#提取匹配项-match" class="headerlink" title="提取匹配项 .match()"></a>提取匹配项 .match()</h3><p>到目前为止，你只是检查了一个匹配模式是否存在于字符串中。你还可以使用<code>.match()</code>方法来提取你找到的实际匹配项。</p>
<p>请使用字符串来调用<code>.match()</code>方法，并在括号内传入正则表达式。以下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"Hello, World!"</span>.match(<span class="regexp">/Hello/</span>);</span><br><span class="line"><span class="comment">// Returns ["Hello"]</span></span><br><span class="line"><span class="keyword">let</span> ourStr = <span class="string">"Regular expressions"</span>;</span><br><span class="line"><span class="keyword">let</span> ourRegex = <span class="regexp">/expressions/</span>;</span><br><span class="line">ourStr.match(ourRegex);</span><br><span class="line"><span class="comment">// Returns ["expressions"]</span></span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h3 id="全局匹配-g"><a href="#全局匹配-g" class="headerlink" title="全局匹配  g"></a>全局匹配  g</h3><p>若要多次搜寻或提取匹配模式，你可以使用<code>g</code>标志。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testStr = <span class="string">"Repeat, Repeat, Repeat"</span>;</span><br><span class="line"><span class="keyword">let</span> repeatRegex = <span class="regexp">/Repeat/g</span>;</span><br><span class="line">testStr.match(repeatRegex);</span><br><span class="line"><span class="comment">// Returns ["Repeat", "Repeat", "Repeat"]</span></span><br></pre></td></tr></table></figure>



<h3 id="通配符-匹配任何内容"><a href="#通配符-匹配任何内容" class="headerlink" title="通配符.匹配任何内容  ."></a>通配符.匹配任何内容  .</h3><p>有时你不会（或不需要）知道匹配模式中的确切字符。如果要精确匹配到完整的单词那出现一个拼写错误就会匹配不到。幸运的是，你可以使用通配符<code>.</code>来处理这种情况。</p>
<p>通配符<code>.</code>将匹配任何一个字符。通配符也叫<code>dot</code>或<code>period</code>。你可以像使用正则表达式中任何其他字符一样使用通配符。例如，如果你想匹配<code>&quot;hug&quot;</code>、<code>&quot;huh&quot;</code>、<code>&quot;hut&quot;</code>和<code>&quot;hum&quot;</code>，你可以使用正则表达式<code>/hu./</code>匹配以上四个单词。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> humStr = <span class="string">"I'll hum a song"</span>;</span><br><span class="line"><span class="keyword">let</span> hugStr = <span class="string">"Bear hug"</span>;</span><br><span class="line"><span class="keyword">let</span> huRegex = <span class="regexp">/hu./</span>;</span><br><span class="line">humStr.match(huRegex); <span class="comment">// Returns ["hum"]</span></span><br><span class="line">hugStr.match(huRegex); <span class="comment">// Returns ["hug"]</span></span><br></pre></td></tr></table></figure>



<h3 id="单个字符有多种可能性"><a href="#单个字符有多种可能性" class="headerlink" title="单个字符有多种可能性 []"></a>单个字符有多种可能性 []</h3><p>你已经了解了如何匹配文字匹配模式（<code>/literal/</code>）和通配符（<code>/./</code>）。这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。在这两种极端情况之间有一个平衡选项。</p>
<p>你可以使用<code>字符集</code>搜寻具有一定灵活性的文字匹配模式。字符集允许你通过把它们放在方括号（<code>[</code>和<code>]</code>）之间的方式来定义一组你需要匹配的字符串。</p>
<p>例如，你想要匹配<code>&quot;bag&quot;</code>、<code>&quot;big&quot;</code>和<code>&quot;bug&quot;</code>，但是不想匹配<code>&quot;bog&quot;</code>。你可以创建正则表达式<code>/b[aiu]g/</code>来执行此操作。<code>[aiu]</code>是只匹配字符<code>&quot;a&quot;</code>、<code>&quot;i&quot;</code>或者<code>&quot;u&quot;</code>的字符集。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bigStr = <span class="string">"big"</span>;</span><br><span class="line"><span class="keyword">let</span> bagStr = <span class="string">"bag"</span>;</span><br><span class="line"><span class="keyword">let</span> bugStr = <span class="string">"bug"</span>;</span><br><span class="line"><span class="keyword">let</span> bogStr = <span class="string">"bog"</span>;</span><br><span class="line"><span class="keyword">let</span> bgRegex = <span class="regexp">/b[aiu]g/</span>;</span><br><span class="line">bigStr.match(bgRegex); <span class="comment">// Returns ["big"]</span></span><br><span class="line">bagStr.match(bgRegex); <span class="comment">// Returns ["bag"]</span></span><br><span class="line">bugStr.match(bgRegex); <span class="comment">// Returns ["bug"]</span></span><br><span class="line">bogStr.match(bgRegex); <span class="comment">// Returns null</span></span><br></pre></td></tr></table></figure>



<h3 id="英文字母-a-z"><a href="#英文字母-a-z" class="headerlink" title="英文字母 [a-z]"></a>英文字母 [a-z]</h3><p>你了解了如何使用<code>字符集</code>来指定要匹配的一组字符串，但是当你需要匹配大量字符（例如，字母表中的每个字母）时，有一种写法可以让实现这个功能变得简短。</p>
<p>在<code>字符集</code>中，你可以使用<code>连字符</code>（<code>-</code>）来定义要匹配的字符范围。</p>
<p>例如，要匹配小写字母<code>a</code>到<code>e</code>，你可以使用<code>[a-e]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> catStr = <span class="string">"cat"</span>;</span><br><span class="line"><span class="keyword">let</span> batStr = <span class="string">"bat"</span>;</span><br><span class="line"><span class="keyword">let</span> matStr = <span class="string">"mat"</span>;</span><br><span class="line"><span class="keyword">let</span> bgRegex = <span class="regexp">/[a-e]at/</span>;</span><br><span class="line">catStr.match(bgRegex); <span class="comment">// Returns ["cat"]</span></span><br><span class="line">batStr.match(bgRegex); <span class="comment">// Returns ["bat"]</span></span><br><span class="line">matStr.match(bgRegex); <span class="comment">// Returns null</span></span><br></pre></td></tr></table></figure>



<h3 id="数字和字母-a-z0-9"><a href="#数字和字母-a-z0-9" class="headerlink" title="数字和字母  [a-z0-9]"></a>数字和字母  [a-z0-9]</h3><p>使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。它还可以匹配一系列数字。</p>
<p>例如，<code>/[0-5]/</code>匹配<code>0</code>和<code>5</code>之间的任意数字，包含<code>0</code>和<code>5</code>。</p>
<p>此外，还可以在单个字符集中组合一系列字母和数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jennyStr = <span class="string">"Jenny8675309"</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/[a-z0-9]/ig</span>;</span><br><span class="line"><span class="comment">// matches all letters and numbers in jennyStr</span></span><br><span class="line">jennyStr.match(myRegex);</span><br></pre></td></tr></table></figure>



<h3 id="不想匹配的字符"><a href="#不想匹配的字符" class="headerlink" title="不想匹配的字符 [^]"></a>不想匹配的字符 [^]</h3><p>你也可以创建一个你不想匹配的字符集合。这些类型的字符集称为<code>否定字符集</code>。</p>
<p>要创建<code>否定字符集</code>，你需要在开始括号后面和不想匹配的字符前面放置<code>插入字符</code>（即<code>^</code>）。</p>
<p>例如，<code>/[^aeiou]/gi</code>匹配所有非元音字符。注意，字符<code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code>和空白字符等也会被匹配，该否定字符集仅排除元音字符。</p>
<h3 id="出现一次或多次的字符"><a href="#出现一次或多次的字符" class="headerlink" title="出现一次或多次的字符  +"></a>出现一次或多次的字符  +</h3><p>至少出现一次，并且可能重复出现。</p>
<p>使用<code>+</code>符号来检查情况是否如此。记住，字符或匹配模式<strong>必须一个接一个地连续出现</strong>。</p>
<p>例如，<code>/a+/g</code>会在<code>&quot;abc&quot;</code>中匹配到一个匹配项，并且返回<code>[&quot;a&quot;]</code>。因为<code>+</code>的存在，它也会在<code>&quot;aabc&quot;</code>中匹配到一个匹配项，然后返回<code>[&quot;aa&quot;]</code>。</p>
<p>如果它是检查字符串<code>&quot;abab&quot;</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。最后，因为在字符串<code>&quot;bcd&quot;</code>中没有<code>&quot;a&quot;</code>，因此找不到匹配项。</p>
<p>当字母<code>z</code>在一行中出现一次或连续多次时，正则表达式<code>/z+/</code>会匹配到它。它会在以下所有字符串中找到匹配项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"z"</span></span><br><span class="line"><span class="string">"zzzzzz"</span></span><br><span class="line"><span class="string">"ABCzzzz"</span></span><br><span class="line"><span class="string">"zzzzABC"</span></span><br><span class="line"><span class="string">"abczzzzzzzzzzzzzzzzzzzzzabc"</span></span><br></pre></td></tr></table></figure>



<h3 id="零次或多次的字符"><a href="#零次或多次的字符" class="headerlink" title="零次或多次的字符  *"></a>零次或多次的字符  *</h3><p>有一个选项可以匹配出现零次或多次的字符。</p>
<p>执行该操作的字符叫做<code>asterisk</code>或<code>star</code>，即<code>*</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> soccerWord = <span class="string">"gooooooooal!"</span>;</span><br><span class="line"><span class="keyword">let</span> gPhrase = <span class="string">"gut feeling"</span>;</span><br><span class="line"><span class="keyword">let</span> oPhrase = <span class="string">"over the moon"</span>;</span><br><span class="line"><span class="keyword">let</span> goRegex = <span class="regexp">/go*/</span>;</span><br><span class="line">soccerWord.match(goRegex); <span class="comment">// Returns ["goooooooo"]</span></span><br><span class="line">gPhrase.match(goRegex); <span class="comment">// Returns ["g"]</span></span><br><span class="line">oPhrase.match(goRegex); <span class="comment">// Returns null</span></span><br></pre></td></tr></table></figure>



<h3 id="用惰性匹配来查找字符-？"><a href="#用惰性匹配来查找字符-？" class="headerlink" title="用惰性匹配来查找字符 ？"></a>用惰性匹配来查找字符 ？</h3><p>在正则表达式中，<code>贪婪</code>匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。另一种方案称为<code>懒惰</code>匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p>
<p>你可以将正则表达式<code>/t[a-z]*i/</code>应用于字符串<code>&quot;titanic&quot;</code>。这个正则表达式是一个以<code>t</code>开始，以<code>i</code>结束，并且中间有一些字母的匹配模式。</p>
<p>正则表达式默认是<code>贪婪</code>匹配，因此匹配返回为<code>[&quot;titani&quot;]</code>。它会匹配到适合该匹配模式的最大子字符串。</p>
<p>但是，你可以使用<code>?</code>字符来将其变成<code>懒惰</code>匹配。调整后的正则表达式<code>/t[a-z]*?i/</code>匹配字符串<code>&quot;titanic&quot;</code>返回<code>[&quot;ti&quot;]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"&lt;h1&gt;Winter is coming&lt;/h1&gt;"</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/&lt;.*?&gt;/</span>; </span><br><span class="line"><span class="keyword">let</span> result = text.match(myRegex);</span><br><span class="line"><span class="comment">//返回 HTML 标签&lt;h1&gt;，而不是文本"&lt;h1&gt;Winter is coming&lt;/h1&gt;"。</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串的开头"><a href="#字符串的开头" class="headerlink" title="字符串的开头 ^"></a>字符串的开头 ^</h3><p>先前的挑战表明，正则表达式可以用于查找许多匹配项。它们还用于搜寻字符串中特定位置的匹配模式。</p>
<p>在之前的挑战中，你使用<code>字符集</code>中的<code>插入</code>符号（<code>^</code>）来创建一个<code>否定字符集</code>，形如<code>[^thingsThatWillNotBeMatched]</code>。在<code>字符集</code>之外，<code>插入</code>符号用于字符串的开头搜寻匹配模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstString = <span class="string">"Ricky is first and can be found."</span>;</span><br><span class="line"><span class="keyword">let</span> firstRegex = <span class="regexp">/^Ricky/</span>;</span><br><span class="line">firstRegex.test(firstString);</span><br><span class="line"><span class="comment">// Returns true</span></span><br><span class="line"><span class="keyword">let</span> notFirst = <span class="string">"You can't find Ricky now."</span>;</span><br><span class="line">firstRegex.test(notFirst);</span><br><span class="line"><span class="comment">// Returns false</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串的末尾"><a href="#字符串的末尾" class="headerlink" title="字符串的末尾 $"></a>字符串的末尾 $</h3><p>还有一种方法可以搜寻字符串末尾的匹配模式。</p>
<p>你可以使用正则表达式的<code>美元</code>符号<code>$</code>来搜寻字符串的结尾。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> theEnding = <span class="string">"This is a never ending story"</span>;</span><br><span class="line"><span class="keyword">let</span> storyRegex = <span class="regexp">/story$/</span>;</span><br><span class="line">storyRegex.test(theEnding);</span><br><span class="line"><span class="comment">// Returns true</span></span><br><span class="line"><span class="keyword">let</span> noEnding = <span class="string">"Sometimes a story will have to end"</span>;</span><br><span class="line">storyRegex.test(noEnding);</span><br><span class="line"><span class="comment">// Returns false</span></span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h3 id="所有的字母和数字-w"><a href="#所有的字母和数字-w" class="headerlink" title="所有的字母和数字 \w"></a>所有的字母和数字 \w</h3><p>使用字符类，你可以使用<code>[a-z]</code>搜寻字母表中的所有字母。这种字符类是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p>
<p>JavaScript 中与字母表匹配的最接近的字符类是<code>\w</code>，这个缩写等同于<code>[A-Za-z0-9_]</code>。它不仅可以匹配大小写字母和数字，注意，它还会匹配下划线字符（<code>_</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> longHand = <span class="regexp">/[A-Za-z0-9_]+/</span>;</span><br><span class="line"><span class="keyword">let</span> shortHand = <span class="regexp">/\w+/</span>;</span><br><span class="line"><span class="keyword">let</span> numbers = <span class="string">"42"</span>;</span><br><span class="line"><span class="keyword">let</span> varNames = <span class="string">"important_var"</span>;</span><br><span class="line">longHand.test(numbers); <span class="comment">// Returns true</span></span><br><span class="line">shortHand.test(numbers); <span class="comment">// Returns true</span></span><br><span class="line">longHand.test(varNames); <span class="comment">// Returns true</span></span><br><span class="line">shortHand.test(varNames); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>

<p>使用缩写<code>\w</code>来计算所有引号中字母和数字字符的数量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">"The five boxing wizards jump quickly."</span>;</span><br><span class="line"><span class="keyword">let</span> alphabetRegexV2 = <span class="regexp">/\w/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(alphabetRegexV2).length;</span><br></pre></td></tr></table></figure>



<h3 id="除了字母和数字的所有符号-W"><a href="#除了字母和数字的所有符号-W" class="headerlink" title="除了字母和数字的所有符号 \W"></a>除了字母和数字的所有符号 \W</h3><p>你可以使用<code>\W</code>搜寻和<code>\w</code>相反的匹配模式。注意，相反匹配模式使用大写字母。此缩写与<code>[^A-Za-z0-9_]</code>是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shortHand = <span class="regexp">/\W/</span>;</span><br><span class="line"><span class="keyword">let</span> numbers = <span class="string">"42%"</span>;</span><br><span class="line"><span class="keyword">let</span> sentence = <span class="string">"Coding!"</span>;</span><br><span class="line">numbers.match(shortHand); <span class="comment">// Returns ["%"]</span></span><br><span class="line">sentence.match(shortHand); <span class="comment">// Returns ["!"]</span></span><br></pre></td></tr></table></figure>



<h3 id="匹配所有数字-amp-非数字-d-D"><a href="#匹配所有数字-amp-非数字-d-D" class="headerlink" title="匹配所有数字 &amp; 非数字  \d \D"></a>匹配所有数字 &amp; 非数字  \d \D</h3><p>查找数字字符的缩写是<code>\d</code>，注意是小写的<code>d</code>。这等同于字符类<code>[0-9]</code>，它查找 0 到 9 之间任意数字的单个字符。</p>
<p>查找非数字字符的缩写是<code>\D</code>。这等同于字符串<code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p>
<h3 id="限制可能的用户名"><a href="#限制可能的用户名" class="headerlink" title="限制可能的用户名"></a>限制可能的用户名</h3><p>用户名在互联网上随处可见。它们是用户在自己喜欢的网站上的唯一身份。</p>
<p>你需要检查数据库中的所有用户名。以下是用户在创建用户名时必须遵守的一些简单规则。</p>
<p>1) 用户名中的数字必须在最后，且数字可以有零个或多个。</p>
<p>2) 用户名字母可以是小写字母和大写字母。</p>
<p>3) 用户名长度必须至少为两个字符。两位用户名只能使用字母。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">"JackOfAllTrades"</span>;</span><br><span class="line"><span class="keyword">let</span> userCheck = <span class="regexp">/^[a-z]&#123;2,&#125;\d*$/i</span>; <span class="comment">// 这一行</span></span><br><span class="line"><span class="keyword">let</span> result = userCheck.test(username);</span><br></pre></td></tr></table></figure>



<h3 id="匹配空白字符-amp-非空白字符"><a href="#匹配空白字符-amp-非空白字符" class="headerlink" title="匹配空白字符 &amp; 非空白字符"></a>匹配空白字符 &amp; 非空白字符</h3><p>匹配字母之间的空格。</p>
<p>以使用<code>\s</code>搜寻空格，其中<code>s</code>是小写。此匹配模式不仅匹配空格，还匹配回车符、制表符、换页符和换行符，你可以将其视为与<code>[\r\t\f\n\v]</code>类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> whiteSpace = <span class="string">"Whitespace. Whitespace everywhere!"</span></span><br><span class="line"><span class="keyword">let</span> spaceRegex = <span class="regexp">/\s/g</span>;</span><br><span class="line">whiteSpace.match(spaceRegex);</span><br><span class="line"><span class="comment">// Returns [" ", " "]</span></span><br></pre></td></tr></table></figure>

<p>也可以搜寻除了空格之外的所有内容。</p>
<p>使用<code>\S</code>搜寻非空白字符，其中<code>S</code>是大写。此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。你可以认为这类似于字符类<code>[^\r\t\f\n\v]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> whiteSpace = <span class="string">"Whitespace. Whitespace everywhere!"</span></span><br><span class="line"><span class="keyword">let</span> nonSpaceRegex = <span class="regexp">/\S/g</span>;</span><br><span class="line">whiteSpace.match(nonSpaceRegex).length; <span class="comment">// Returns 32</span></span><br></pre></td></tr></table></figure>



<h3 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h3><p>回想一下，你使用加号<code>+</code>查找一个或多个字符，使用星号<code>*</code>查找零个或多个字符。这些都很方便，但有时你需要匹配一定范围的匹配模式。</p>
<p>你可以使用<code>数量说明符</code>指定匹配模式的上下限。数量说明符与花括号（<code>{</code>和<code>}</code>）一起使用。你可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p>
<p>例如，要在字符串<code>&quot;ah&quot;</code>中匹配仅出现<code>3</code>到<code>5</code>次的字母<code>a</code>，你的正则表达式应为<code>/a{3,5}h/</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A4 = <span class="string">"aaaah"</span>;</span><br><span class="line"><span class="keyword">let</span> A2 = <span class="string">"aah"</span>;</span><br><span class="line"><span class="keyword">let</span> multipleA = <span class="regexp">/a&#123;3,5&#125;h/</span>;</span><br><span class="line">multipleA.test(A4); <span class="comment">// Returns true</span></span><br><span class="line">multipleA.test(A2); <span class="comment">// Returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>只指定匹配的下限</strong></p>
<p>你可以使用带有花括号的<code>数量说明符</code>来指定匹配模式的上下限。但有时候你只想指定匹配模式的下限而不需要指定上限。</p>
<p>为此，在第一个数字后面跟一个逗号即可。</p>
<p>例如，要匹配至少出现<code>3</code>次字母<code>a</code>的字符串<code>&quot;hah&quot;</code>，你的正则表达式应该是<code>/ha{3,}h/</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A4 = <span class="string">"haaaah"</span>;</span><br><span class="line"><span class="keyword">let</span> A2 = <span class="string">"haah"</span>;</span><br><span class="line"><span class="keyword">let</span> A100 = <span class="string">"h"</span> + <span class="string">"a"</span>.repeat(<span class="number">100</span>) + <span class="string">"h"</span>;</span><br><span class="line"><span class="keyword">let</span> multipleA = <span class="regexp">/ha&#123;3,&#125;h/</span>;</span><br><span class="line">multipleA.test(A4); <span class="comment">// Returns true</span></span><br><span class="line">multipleA.test(A2); <span class="comment">// Returns false</span></span><br><span class="line">multipleA.test(A100); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>

<p><strong>指定匹配的确切数量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A4 = <span class="string">"haaaah"</span>;</span><br><span class="line"><span class="keyword">let</span> A3 = <span class="string">"haaah"</span>;</span><br><span class="line"><span class="keyword">let</span> A100 = <span class="string">"h"</span> + <span class="string">"a"</span>.repeat(<span class="number">100</span>) + <span class="string">"h"</span>;</span><br><span class="line"><span class="keyword">let</span> multipleHA = <span class="regexp">/a&#123;3&#125;h/</span>;</span><br><span class="line">multipleHA.test(A4); <span class="comment">// Returns false</span></span><br><span class="line">multipleHA.test(A3); <span class="comment">// Returns true</span></span><br><span class="line">multipleHA.test(A100); <span class="comment">// Returns false</span></span><br></pre></td></tr></table></figure>



<h3 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h3><p>有时，你想要搜寻的匹配模式可能有不确定是否存在的部分。尽管如此，你还是想检查它们。</p>
<p>为此，你可以使用问号<code>?</code>指定可能存在的元素。这将<strong>检查前面的零个或一个元素</strong>。你可以将此符号视为前面的元素是可选的。</p>
<p>例如，美式英语和英式英语略有不同，你可以使用问号来匹配两种拼写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> american = <span class="string">"color"</span>;</span><br><span class="line"><span class="keyword">let</span> british = <span class="string">"colour"</span>;</span><br><span class="line"><span class="keyword">let</span> rainbowRegex= <span class="regexp">/colou?r/</span>;</span><br><span class="line">rainbowRegex.test(american); <span class="comment">// Returns true</span></span><br><span class="line">rainbowRegex.test(british); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>



<h3 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h3><p><code>先行断言</code>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。</p>
<p>有两种<code>先行断言</code>：<code>正向先行断言</code>和<code>负向先行断言</code>。</p>
<p><code>正向先行断言</code>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分。</p>
<p>另一方面，<code>负向先行断言</code>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p>
<p>尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> quit = <span class="string">"qu"</span>;</span><br><span class="line"><span class="keyword">let</span> noquit = <span class="string">"qt"</span>;</span><br><span class="line"><span class="keyword">let</span> quRegex= <span class="regexp">/q(?=u)/</span>;</span><br><span class="line"><span class="keyword">let</span> qRegex = <span class="regexp">/q(?!u)/</span>;</span><br><span class="line">quit.match(quRegex); <span class="comment">// Returns ["q"]</span></span><br><span class="line">noquit.match(qRegex); <span class="comment">// Returns ["q"]</span></span><br></pre></td></tr></table></figure>

<p><code>先行断言</code>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> password = <span class="string">"abc123"</span>;</span><br><span class="line"><span class="keyword">let</span> checkPass = <span class="regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span>;</span><br><span class="line">checkPass.test(password); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure>

<p>在正则表达式<code>pwRegex</code>中使用<code>先行断言</code>以匹配至少5个字符且有两个连续数字的密码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleWord = <span class="string">"astronaut"</span>;</span><br><span class="line"><span class="keyword">let</span> pwRegex = <span class="regexp">/(?=\w&#123;5,&#125;)(?=\D*\d\d)/</span>; <span class="comment">// </span></span><br><span class="line"><span class="keyword">let</span> result = pwRegex.test(sampleWords); <span class="comment">//Returns true</span></span><br></pre></td></tr></table></figure>



<h3 id="使用捕获组重用模式"><a href="#使用捕获组重用模式" class="headerlink" title="使用捕获组重用模式"></a>使用捕获组重用模式</h3><p>一些你所搜寻的匹配模式会在字符串中出现多次，手动重复该正则表达式太浪费了。有一种更好的方法可以指定何时在字符串中会有多个重复的子字符串。</p>
<p>你可以使用<code>捕获组</code>搜寻重复的子字符串。括号<code>(</code>和<code>)</code>可以用来匹配重复的子字符串。你只需要把重复匹配模式的正则表达式放在括号中即可。</p>
<p>要指定重复字符串将出现的位置，可以使用反斜杠（<code>\</code>）后接一个数字。这个数字从 1 开始，随着你使用的每个捕获组的增加而增加。这里有一个示例，<code>\1</code>可以匹配第一个组。</p>
<p>下面的示例匹配任意两个被空格分割的单词：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatStr = <span class="string">"regex regex"</span>;</span><br><span class="line"><span class="keyword">let</span> repeatRegex = <span class="regexp">/(\w+)\s\1/</span>;</span><br><span class="line">repeatRegex.test(repeatStr); <span class="comment">// Returns true</span></span><br><span class="line">repeatStr.match(repeatRegex); <span class="comment">// Returns ["regex regex", "regex"]</span></span><br></pre></td></tr></table></figure>



<p>在字符串上使用<code>.match()</code>方法将返回一个数组，其中包含它匹配的字符串及其捕获组。</p>
<p>在正则表达式<code>reRegex</code>中使用<code>捕获组</code>，以匹配在字符串中仅重复三次的数字，每一个都由空格分隔:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatNum = <span class="string">"42 42 42"</span>;</span><br><span class="line"><span class="keyword">let</span> reRegex = <span class="regexp">/^(\d+)\s\1\s\1$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = reRegex.test(repeatNum);</span><br><span class="line"><span class="built_in">console</span>.log(repeatNum.match(reRegex));<span class="comment">// ["42 42 42", "42"]</span></span><br></pre></td></tr></table></figure>



<h3 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h3><p>搜索功能是很有用的。但是，当你的搜索也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p>
<p>可以使用字符串上<code>.replace()</code>方法来搜索并替换字符串中的文本。<code>.replace()</code>的输入首先是你想要搜索的正则表达式匹配模式，第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrongText = <span class="string">"The sky is silver."</span>;</span><br><span class="line"><span class="keyword">let</span> silverRegex = <span class="regexp">/silver/</span>;</span><br><span class="line">wrongText.replace(silverRegex, <span class="string">"blue"</span>);</span><br><span class="line"><span class="comment">// Returns "The sky is blue."</span></span><br></pre></td></tr></table></figure>



<p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"Code Camp"</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2 $1'</span>);</span><br><span class="line"><span class="comment">// Returns "Camp Code"</span></span><br></pre></td></tr></table></figure>



<h3 id="删除开头和结尾的空白"><a href="#删除开头和结尾的空白" class="headerlink" title="删除开头和结尾的空白"></a>删除开头和结尾的空白</h3><p>有时字符串周围存在的空白字符并不是必需的。字符串的典型处理是删除字符串开头和结尾处的空格。</p>
<p>编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。</p>
<p><strong>注意：</strong><br><code>.trim()</code>方法在这里也可以实现同样的效果，但是现在使用正则表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"   Hello, World!  "</span>;</span><br><span class="line"><span class="keyword">let</span> wsRegex = <span class="regexp">/^\s+|\s+$/g</span>; </span><br><span class="line"><span class="keyword">let</span> result = hello.replace(wsRegex,<span class="string">''</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
        <category>笔记</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据结构</title>
    <url>/2020/05/07/05%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 JavaScript 和其他编程语言中，我们都可以以多种方式存储和访问数据。本节将教你如何使用数组（array），以及如何访问和复制数组中的信息。本节还将教你如何用点符号和方括号符号来操作和访问 JavaScript 对象（object）中的信息。学习此文档你应该掌握数组和对象的基本属性以及它们之间的区别，并且掌握如何选择它们来实现给定的目标。</p>
<h3 id="使用数组存储数据集合"><a href="#使用数组存储数据集合" class="headerlink" title="使用数组存储数据集合"></a>使用数组存储数据集合</h3><p>下面是一个关于数组的更复杂的例子。这是一个多维数组（multi-dimensional Array），或者说是一个包含了其他数组的数组。你可以注意到，在它的内部还包含了 JavaScript 中的对象（objects）结构。我们会在后面的小节中讨论该数据结构，但现在你只需要知道<strong>数组能够存储复杂的对象类型数据</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> complexArray = [</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      one: <span class="number">1</span>,</span><br><span class="line">      two: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      three: <span class="number">3</span>,</span><br><span class="line">      four: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      a: <span class="string">"a"</span>,</span><br><span class="line">      b: <span class="string">"b"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      c: <span class="string">"c"</span>,</span><br><span class="line">      d: “d”</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>



<h3 id="使用-push-和-unshift-添加项目到数组中"><a href="#使用-push-和-unshift-添加项目到数组中" class="headerlink" title="使用 push() 和 unshift() 添加项目到数组中"></a>使用 push() 和 unshift() 添加项目到数组中</h3><p><code>Array.push()</code>和<code>Array.unshift()</code>。</p>
<p>这两个方法都接收一个或多个元素作为参数；对一个数组调用这两个方法都可以将输入的元素插入到该数组中；<code>push()</code>方法将元素插入到一个数组的末尾，而<code>unshift()</code>方法将元素插入到一个数组的开头。请看以下例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> twentyThree = <span class="string">'XXIII'</span>;</span><br><span class="line"><span class="keyword">let</span> romanNumerals = [<span class="string">'XXI'</span>, <span class="string">'XXII'</span>];</span><br><span class="line"></span><br><span class="line">romanNumerals.unshift(<span class="string">'XIX'</span>, <span class="string">'XX'</span>);</span><br><span class="line"><span class="comment">// 数组现在为 ['XIX', 'XX', 'XXI', 'XXII']</span></span><br><span class="line"></span><br><span class="line">romanNumerals.push(twentyThree);</span><br><span class="line"><span class="comment">// 数组现在为 ['XIX', 'XX', 'XXI', 'XXII', 'XXIII']</span></span><br></pre></td></tr></table></figure>

<p>注意，我们还可以输入变量，这允许我们很灵活地动态改变我们数组中的数据。</p>
<h3 id="使用-pop-和-shift-从数组中删除项目"><a href="#使用-pop-和-shift-从数组中删除项目" class="headerlink" title="使用 pop() 和 shift() 从数组中删除项目"></a>使用 pop() 和 shift() 从数组中删除项目</h3><p>与前面讲的相反。</p>
<p>作用分别是删除数组最后一个元素和删除数组第一个元素。并返回其值。</p>
<h3 id="使用-splice-删除项目"><a href="#使用-splice-删除项目" class="headerlink" title="使用 splice() 删除项目"></a>使用 splice() 删除项目</h3><p>在上面的挑战中，我们已经学到了如何利用<code>shift()</code>和<code>pop()</code>从数组的开头或者末尾移除元素，但如果我们想移除数组中间的一个元素呢？或者想一次移除多个元素呢？这时候我们就需要<code>splice()</code>了。<code>splice()</code>让我们可以从数组中的任意位置<strong>移除任意数量的连续的元素</strong>。</p>
<p><code>splice()</code>最多可以接受 3 个参数，但现在我们先关注前两个。<code>splice()</code>接收的前两个参数基于调用<code>splice()</code>数组中元素的索引。<code>splice()</code>的第一个参数代表从数组中的哪个索引开始移除元素，而第二个参数指示要从数组中删除多少个元素。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">'today'</span>, <span class="string">'was'</span>, <span class="string">'not'</span>, <span class="string">'so'</span>, <span class="string">'great'</span>];</span><br><span class="line"></span><br><span class="line">array.splice(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 从第 3 个元素开始，删除 2 个元素</span></span><br><span class="line"><span class="comment">// 现在该数组等于 ['today', 'was', 'great']</span></span><br></pre></td></tr></table></figure>

<p><code>splice()</code>不仅从被调用的数组中移除元素，还会返回一个包含被移除元素的数组.</p>
<h3 id="使用-splice-增加项目"><a href="#使用-splice-增加项目" class="headerlink" title="使用 splice() 增加项目"></a>使用 splice() 增加项目</h3><p><code>splice()</code>方法可以接受最多 3 个参数,我们现在可以进一步了解<code>splice()</code>。除了移除元素，我们还可以利用它的第三个参数来向数组中<em>添加</em>元素。第三个参数可以是一个或多个元素，这些元素会被添加到数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorChange</span>(<span class="params">arr, index, newColor</span>) </span>&#123;</span><br><span class="line">  arr.splice(index, <span class="number">1</span>, newColor);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colorScheme = [<span class="string">'#878787'</span>, <span class="string">'#a08794'</span>, <span class="string">'#bb7e8c'</span>, <span class="string">'#c9b6be'</span>, <span class="string">'#d1becf'</span>];</span><br><span class="line"></span><br><span class="line">colorScheme = colorChange(colorScheme, <span class="number">2</span>, <span class="string">'#332327'</span>);</span><br><span class="line"><span class="comment">// 我们移除了 '#bb7e8c' 并在其位置上添加了 '#332327'</span></span><br><span class="line"><span class="comment">// colorScheme 现在等于 ['#878787', '#a08794', '#332327', '#c9b6be', '#d1becf']</span></span><br></pre></td></tr></table></figure>



<h3 id="使用-slice-拷贝数组项目"><a href="#使用-slice-拷贝数组项目" class="headerlink" title="使用 slice() 拷贝数组项目"></a>使用 slice() 拷贝数组项目</h3><p><code>slice()</code>并不修改数组，而是复制或者说<em>提取（extract）</em>给定数量的元素到一个新数组里，而调用方法的数组则保持不变。<code>slice()</code>只接受 2 个输入参数—<strong>第一个是开始提取元素的位置（索引）</strong>，<strong>第二个是结束提取元素的位置（索引）</strong>。slice 方法会提取直到该索引的元素，但被提取的元素不包括该索引对应的元素。（不包含后面索引对应的值）请看以下例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weatherConditions = [<span class="string">'rain'</span>, <span class="string">'snow'</span>, <span class="string">'sleet'</span>, <span class="string">'hail'</span>, <span class="string">'clear'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todaysWeather = weatherConditions.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// todaysWeather 等于 ['snow', 'sleet'];</span></span><br><span class="line"><span class="comment">// weatherConditions 仍然等于 ['rain', 'snow', 'sleet', 'hail', 'clear']</span></span><br></pre></td></tr></table></figure>



<h3 id="使用扩展运算符复制数组"><a href="#使用扩展运算符复制数组" class="headerlink" title="使用扩展运算符复制数组"></a>使用扩展运算符复制数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slice()&#96;已经能让我们从一个数组中选择一些元素来复制到新数组中了，而 ES6 中又新引入了一个简洁且可读性强的语法展开运算符（spread operator），它能让我们方便地复制数组中的*所有*元素。展开语法是这样的：&#96;...</span><br></pre></td></tr></table></figure>

<p>在实践中，我们可以这样用展开运算符来复制一个数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thisArray = [<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">false</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="keyword">let</span> thatArray = [...thisArray];</span><br><span class="line"><span class="comment">// thatArray 等于 [true, true, undefined, false, null]</span></span><br><span class="line"><span class="comment">// thisArray 保持不变，并等于 thatArray</span></span><br></pre></td></tr></table></figure>



<h3 id="使用-indexOf-检查元素是否存在"><a href="#使用-indexOf-检查元素是否存在" class="headerlink" title="使用 indexOf() 检查元素是否存在"></a>使用 indexOf() 检查元素是否存在</h3><p>由于数组可以在任意时间被修改或者说<em>被改变（mutated）</em>，我们不能保证某个数据在一个给定数组中的位置，甚至不能保证该元素还存在于该数组中。幸运的是，JavaScript 给我们提供了另一个内置方法<code>indexOf()</code>。这个方法让我们可以便捷地检查某个元素是否存在于一个数组中。<code>indexOf()</code>方法接受一个元素作为输入参数，并返回该元素在数组中的位置（索引）；若该元素不存在于数组中则返回<code>-1</code>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">'apples'</span>, <span class="string">'pears'</span>, <span class="string">'oranges'</span>, <span class="string">'peaches'</span>, <span class="string">'pears'</span>];</span><br><span class="line"></span><br><span class="line">fruits.indexOf(<span class="string">'dates'</span>) <span class="comment">// 返回 -1</span></span><br><span class="line">fruits.indexOf(<span class="string">'oranges'</span>) <span class="comment">// 返回 2</span></span><br><span class="line">fruits.indexOf(<span class="string">'pears'</span>) <span class="comment">// 返回 1，即第一个出现的 'pears' 元素在数组中的索引为 1</span></span><br></pre></td></tr></table></figure>



<h3 id="使用-For-循环迭代数组的所有项"><a href="#使用-For-循环迭代数组的所有项" class="headerlink" title="使用 For 循环迭代数组的所有项"></a>使用 For 循环迭代数组的所有项</h3><p>在进行与数组有关的编程时，我们有时需要遍历数组的所有元素来找出我们需要的元素，或者对数组执行特定的操作。JavaScript 提供了几个内置的方法，它们以不同的方式遍历数组来获得不同的结果（如<code>every()</code>、<code>forEach()</code>、<code>map()</code>等等）。而简单的<code>for</code>循环不仅能实现这些功能，而且相比之下也更灵活。</p>
<p>请看以下例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greaterThanTen</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> newArr = [];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">10</span>) &#123;</span><br><span class="line">   newArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greaterThanTen([<span class="number">2</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 返回 [12, 14, 80]</span></span><br></pre></td></tr></table></figure>



<h3 id="使用方括号访问属性名称"><a href="#使用方括号访问属性名称" class="headerlink" title="使用方括号访问属性名称"></a>使用方括号访问属性名称</h3><p>我们可以使用点操作符和方括号访问对象的属性值。</p>
<p>假设一个超市的收银台的程序中使用了一个<code>foods</code>对象，并且有一些程序逻辑会设置<code>selectedFood</code>，我们需要查询<code>foods</code>对象来检查某种食物是否存在，我们可以这样写检查逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedFood = getCurrentFood(scannedItem);</span><br><span class="line"><span class="keyword">let</span> inventory = foods[selectedFood];</span><br></pre></td></tr></table></figure>



<p>上述代码会先计算<code>selectedFood</code>变量的值，并返回<code>foods</code>对象中以该值命名的属性对应的值，若没有以该值命名的属性则会返回<code>undefined</code>。有时候对象的属性名在运行之前是不确定的，或者我们需要动态地访问对象的属性，这时方括号符号就会很有用。</p>
<h3 id="使用-delete-关键字删除对象属性"><a href="#使用-delete-关键字删除对象属性" class="headerlink" title="使用 delete 关键字删除对象属性"></a>使用 delete 关键字删除对象属性</h3><p>果我们想移除<code>apples</code>属性，我们可以使用<code>delete</code>关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> foods.apples;</span><br></pre></td></tr></table></figure>



<h3 id="使用-for…in-语句迭代对象"><a href="#使用-for…in-语句迭代对象" class="headerlink" title="使用 for…in 语句迭代对象"></a>使用 for…in 语句迭代对象</h3><p>有时候你需要遍历一个对象中的所有键。这需要 JavaScript 中的一个特殊语法：for…in 语句。以遍历 <code>users</code>对象的键为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">in</span> users) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">Alan</span><br><span class="line">Jeff</span><br><span class="line">Sarah</span><br><span class="line">Ryan</span><br></pre></td></tr></table></figure>

<p>在这个语句中，我们定义了一个<code>user</code>变量，你可以看到，这个变量在 for…in 语句对对象的每一个键的遍历中都会被重置。</p>
<p><strong>注意：</strong><br>跟数组不同，对象中的键是无序的，因此一个对象中某个键的位置，或者说它出现的相对顺序，在引用或访问该键时是不确定的。</p>
<h3 id="使用-Object-keys-生成对象所有键组成的数组"><a href="#使用-Object-keys-生成对象所有键组成的数组" class="headerlink" title="使用 Object.keys() 生成对象所有键组成的数组"></a>使用 Object.keys() 生成对象所有键组成的数组</h3><p>我们还可以输入一个对象作为参数来调用<code>Object.keys()</code>方法，使其生成一个包含对象中所有键的数组。这会返回一个由对象中所有键的名称（字符串）组成的数组。再次说明，这个数组中的项的顺序是不确定的。</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>js笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/2020/05/07/06%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><p><a href="https://blog.csdn.net/qq_35809245/article/details/54895612" target="_blank" rel="noopener">常用的jsAPI –孤枫_J</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>计算机算法是产生特定结果的一系列步骤。要写一个算法，你必须先理解一个特定的问题，然后编写代码去解决它。</p>
<p>将问题化整为零会让你更容易地解决问题。然后你就可以逐一解决这些子问题。例如，如果你要开发一个计算器，不要试图一下子解决整个问题，而是首先考虑怎样获取用户的输入，然后一个一个地实现每一种算术运算，最后实现运算结果的展示。</p>
<p>学习使用 JavaScript 来解决一些基础的算法问题。这会帮助你提升解决问题的能力，并为接下来解决更复杂的问题打下基础。</p>
<h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><p>反转给出的字符串。</p>
<p>你在反转字符串前可能需要将其切分成字符的数组。</p>
<p>你的结果必须是一个字符串。</p>
<p>笨方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str1 = str.split(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">var</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,j = str1.length<span class="number">-1</span>;i&lt;str1.length/<span class="number">2</span>;i++,j--)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = str1[i];</span><br><span class="line">    str1[i] = str1[j];</span><br><span class="line">    str1[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  str = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>;k&lt;str1.length;k++)</span><br><span class="line">    str += str1[k];</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">reverseString(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<p>完美简洁版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将字符串按每个字符切割，然后反转数组，最后再拼接成字符串。</p>
<h3 id="数字的阶乘"><a href="#数字的阶乘" class="headerlink" title="数字的阶乘"></a>数字的阶乘</h3><p>返回一个给定整数的阶乘。</p>
<p>若 n 是一个整数，n 的阶乘就是所有小于等于 n 的正整数的乘积。</p>
<p>n 的阶乘通常用符号 <code>n!</code>来表示。</p>
<p>例如： <code>5! = 1 * 2 * 3 * 4 * 5 = 120</code></p>
<p>只有非负整数会被作为函数的输入参数。</p>
<p>非递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialize</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> i = num;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">2</span>)</span><br><span class="line">      num *= i;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorialize(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialize</span>(<span class="params">num</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num === <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> num*factorialize(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorialize(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h3 id="查找字符串中最长的单词"><a href="#查找字符串中最长的单词" class="headerlink" title="查找字符串中最长的单词"></a>查找字符串中最长的单词</h3><p>返回给出的句子中最长的单词的长度。</p>
<p>方法1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongestWordLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str1 = str.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">var</span> max = str1[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; str1.length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;str1[i].length)</span><br><span class="line">    max = str1[i].length; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findLongestWordLength(<span class="string">"The quick brown fox jumped over the lazy dog"</span>);</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<p>使用.reduce()   <a href="https://www.jianshu.com/p/e375ba1cfc47" target="_blank" rel="noopener">了解.reduce()</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongestWordLength</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.split(<span class="string">' '</span>)</span><br><span class="line">    .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.max(x, y.length)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3：使用递归，我们检查是否<code>str</code>只剩下1个元素，那是最长的元素，然后返回它。如果第一个元素的长度大于第二个元素的长度（或相等），则删除第二个元素并递归调用function <code>findLongestWord</code>。反之删除第一个再调用。</p>
<h3 id="返回数组中最大的数字"><a href="#返回数组中最大的数字" class="headerlink" title="返回数组中最大的数字"></a>返回数组中最大的数字</h3><p>返回一个数组，它要由给出的所有子数组中的最大值组成。简单起见，给出的数组总会包含4个子数组。</p>
<p>最初版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// You can do this! </span></span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    newArr.push(arr[i].reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span><span class="built_in">Math</span>.max(x,y),<span class="number">0</span>)); <span class="comment">//这个0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestOfFour([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">13</span>, <span class="number">27</span>, <span class="number">18</span>, <span class="number">26</span>], [<span class="number">32</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">39</span>], [<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">857</span>, <span class="number">1</span>]]);</span><br></pre></td></tr></table></figure>

<p>报错：<code>largestOfFour([[17, 23, 25, 12], [25, 7, 34, 48], [4, -10, 18, 21], [-72, -3, -17, -10]])</code>应该返回 <code>[25, 48, 21, -3]</code>。    </p>
<p>调试发现程序返回的是[25,48,21,0]，困惑怎么会返回0，Math.max()可以使用在正数负数以及小数。再次查看.reduce()的方法发现填加末尾的0，是给定初始值为0，而不是-72，导致出错。不添加初始值则默认为数组第一个元素。</p>
<p>删去0即可ac。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">newArr.push(arr[i].reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span><span class="built_in">Math</span>.max(x,y));</span><br></pre></td></tr></table></figure>

<p>这道题使用.map()方法更为简洁</p>
<p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">group</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span><span class="built_in">Math</span>.max(x,y));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高级：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="built_in">Function</span>.apply.bind(<span class="built_in">Math</span>.max, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="检查字符串的结尾"><a href="#检查字符串的结尾" class="headerlink" title="检查字符串的结尾"></a>检查字符串的结尾</h3><p>检查一个字符串（第一个参数， <code>str</code>）是否以给定的字符串（第二个参数 <code>target</code>）结束。</p>
<p>本题目<em>可以</em>用 ES2015 引入的 <code>.endsWith()</code>方法来解决。但本挑战的目的是使用 JavaScript 的一个 substring 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmEnding</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// "Never give up and good luck will find you."</span></span><br><span class="line">  <span class="comment">// -- Falcor</span></span><br><span class="line">  <span class="keyword">var</span> tar = target.length;</span><br><span class="line">  <span class="keyword">var</span> str1 = str.substring(str.length-tar<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span>(str1.indexOf(target)!=<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">confirmEnding(<span class="string">"Bastian"</span>, <span class="string">"n"</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用.slice()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmEnding</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// "Never give up and good luck will find you."</span></span><br><span class="line">  <span class="comment">// -- Falcor</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> str.slice(str.length - target.length) === target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">confirmEnding(<span class="string">"He has to give me a new name"</span>, <span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h3><p>将一个给定的字符串（第一个参数， <code>str</code>)重复 <code>num</code>（第二个参数）次。如果 <code>num</code>不是一个正数，返回一个空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatStringNumTimes</span>(<span class="params">str, num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// repeat after me</span></span><br><span class="line">  <span class="keyword">var</span> str1 = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;num ; i++)</span><br><span class="line">    str1 = str1.concat(str);   <span class="comment">// str1 += str;</span></span><br><span class="line">  <span class="keyword">return</span> str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeatStringNumTimes(<span class="string">"abc"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatStringNumTimes</span>(<span class="params">str, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> str + repeatStringNumTimes(str, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.repeat()版：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatStringNumTimes</span>(<span class="params">str, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> ? str.repeat(num) : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="截断字符串"><a href="#截断字符串" class="headerlink" title="截断字符串"></a>截断字符串</h3><p>如果一个字符串（第一个参数）的长度大于给出的值（第二个参数），则截断它并在其后加上 <code>...</code>。返回被截断的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncateString</span>(<span class="params">str, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length &gt; num ) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">0</span>, num) + <span class="string">'...'</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">truncateString(<span class="string">"A-tisket a-tasket A green and yellow basket"</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>



<h3 id="算法基础：发现者与看护者"><a href="#算法基础：发现者与看护者" class="headerlink" title="算法基础：发现者与看护者"></a>算法基础：发现者与看护者</h3><p>请写一个函数来检查一个数组（第一个参数）中的元素，并返回数组中第一个通过校验测试（第二个参数，一个接受一个参数并返回一个布尔值的函数）的元素。如果没有元素通过测试，则返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findElement</span>(<span class="params">arr, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> arr1 = arr.filter(func); <span class="comment">//每个成员执行函数func，返回通过的成员组成的新数组</span></span><br><span class="line">  <span class="keyword">if</span>(arr1)</span><br><span class="line">    <span class="keyword">return</span> arr1[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], num =&gt; num % <span class="number">2</span> === <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="单词首字母大写"><a href="#单词首字母大写" class="headerlink" title="单词首字母大写"></a>单词首字母大写</h3><p>将给出的字符串中所有单词的第一个字母变成大写，并返回得到的字符串。请确保其余的字母是小写的。</p>
<p>出于练习的目的，“ the ”“ of ”等虚词的首字母也要大写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单易懂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> str1 = str.split(<span class="string">" "</span>);</span><br><span class="line">  <span class="keyword">var</span> str2=<span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;str1.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    str2 += str1[i].substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+str1[i].substring(<span class="number">1</span>)+<span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  str2 = str2.trim(); <span class="comment">//去除最后面的那个空格</span></span><br><span class="line">  <span class="keyword">return</span> str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">titleCase(<span class="string">"I'm a little tea pot"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(^|\s)\S/g</span>, (L) =&gt; L.toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line">titleCase(<span class="string">"I'm a little tea pot"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="slice-和-splice"><a href="#slice-和-splice" class="headerlink" title="slice 和 splice"></a>slice 和 splice</h3><p>输入参数为：两个数组和一个索引值。</p>
<p>请利用数组的 <code>slice</code>和 <code>splice</code>方法，将第一个数组中的所有元素依次复制到第二个数组中。</p>
<p>请从第二个数组中索引值为 <code>n</code>的地方开始插入。</p>
<p>返回插入元素后的数组。输入的两个数组在函数执行前后要保持不变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frankenSplice</span>(<span class="params">arr1, arr2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr3 = arr2.slice();  <span class="comment">//复制数组arr2</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;arr1.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      arr3.splice(n,<span class="number">0</span>,arr1[j]);  <span class="comment">//添加到指定位置</span></span><br><span class="line">      n++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> arr3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frankenSplice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="去除数组中的假值"><a href="#去除数组中的假值" class="headerlink" title="去除数组中的假值"></a>去除数组中的假值</h3><p>从一个数组中移除所有假值（falsy values）。</p>
<p>JavaScript 中的假值有 <code>false</code>、<code>null</code>、<code>0</code>、<code>&quot;&quot;</code>、<code>undefined</code>和 <code>NaN</code>。</p>
<p>提示：请尝试将每一个值转换为一个布尔值（boolean）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bouncer</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bouncer([<span class="number">7</span>, <span class="string">"ate"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="number">9</span>]);</span><br></pre></td></tr></table></figure>

<p><code>**filter()**</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p>
<h3 id="我身在何处"><a href="#我身在何处" class="headerlink" title="我身在何处"></a>我身在何处</h3><p>返回数组（第一个参数）被排序后，将一个值（第二个参数）插入到该数组中而使数组保持有序的最小的索引。返回的值应该是一个数字。</p>
<p>例如，<code>getIndexToIns([1,2,3,4], 1.5)</code>应该返回 <code>1</code>因为 1.5 大于 <code>1</code>（索引为 0），但小于 <code>2</code>（索引为 1）。</p>
<p>同样地，<code>getIndexToIns([20,3,5], 19)</code>应该返回 <code>2</code>因为数组被排序后会变成 <code>[3,5,20]</code>，而 <code>19</code>小于 <code>20</code>（索引为 2）且大于 <code>5</code>（索引为 1）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndexToIns</span>(<span class="params">arr, num</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Find my place in this sorted array.</span></span><br><span class="line">  arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&gt;=num)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getIndexToIns([<span class="number">40</span>, <span class="number">60</span>], <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//精简高级版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndexToIns</span>(<span class="params">arr, num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.concat(num).sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b).indexOf(num);<span class="comment">//一行</span></span><br><span class="line">&#125;</span><br><span class="line">getIndexToIns([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h3 id="集合之间的关系"><a href="#集合之间的关系" class="headerlink" title="集合之间的关系"></a>集合之间的关系</h3><p>输入参数是一个有两个字符串元素的数组。如果第一个字符串中包含了第二个字符串中的所有字母，则返回 true。</p>
<p>例如，<code>[&quot;hello&quot;, &quot;Hello&quot;]</code>应该返回 true 因为第一个字符串中包含了第二个字符串中出现的所有字母（忽略大小写）。</p>
<p>而 <code>[&quot;hello&quot;, &quot;hey&quot;]</code>应该返回 false 因为第一个字符串 “hello” 没有包含字母 “y”。</p>
<p>最后，<code>[&quot;Alien&quot;, &quot;line&quot;]</code>, 应该返回 true，因为 “line” 中的所有字母都被包含在 “Alien” 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutation</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=arr[<span class="number">0</span>].toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> b=arr[<span class="number">1</span>].toLowerCase();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;b.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a.indexOf(b[i])&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"hey"</span>]);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="猴子吃香蕉"><a href="#猴子吃香蕉" class="headerlink" title="猴子吃香蕉"></a>猴子吃香蕉</h3><p>写一个函数，将一个数组（第一个参数）分割成一组长度为 <code>size</code>（第二个参数）的数组，然后在一个二维数组中返回这些结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunkArrayInGroups</span>(<span class="params">arr, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr2=[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i+=size)</span><br><span class="line">  &#123;</span><br><span class="line">    arr2.push(arr.slice(i,i+size));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chunkArrayInGroups([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>], <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
        <category>笔记</category>
        <category>js笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程</title>
    <url>/2020/05/07/07%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>面向对象编程是软件开发过程的几种主要方法之一。</p>
<p>顾名思义，面向对象编程将代码组织成对象定义。这些有时被称为类，它们将数据和相关行为组合在一起。数据是对象的属性，行为(或函数)是方法。</p>
<p>对象结构能够在程序中灵活使用，比如对象可以通过调用数据并将数据传递给另一个对象的方法来传递信息。此外，新对象可以从基类（或父类）接收或继承所有功能，这有助于减少重复代码。</p>
<p>对于编程方法的选择取决于几个因素，其中包括问题的类型、如何构造数据以及算法等。这里介绍 JavaScript 中面向对象的编程原则。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> duck = &#123;</span><br><span class="line">  name: <span class="string">"Aflac"</span>,</span><br><span class="line">  numLegs: <span class="number">2</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"The name of this duck is "</span> + <span class="keyword">this</span>.name + <span class="string">"."</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>构造函数</code>遵循一些惯例规则：</p>
<ul>
<li><code>构造函数</code>函数名的首字母最好大写，这是为了方便我们区分<code>构造函数</code>和其他非构造函数。</li>
<li><code>构造函数</code>使用<code>this</code>关键字来给它将创建的这个对象设置新的属性。在<code>构造函数</code>里面，<code>this</code>指向的就是它新创建的这个对象。</li>
<li><code>构造函数</code>定义了属性和行为就可创建对象，而不是像其他函数一样需要设置返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Wangcai"</span>;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="string">"green"</span>;</span><br><span class="line">    <span class="keyword">this</span>.numLegs = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>通过构造函数创建对象的时候要使用<code>new</code>操作符。因为只有这样，JavaScript 才知道要给<code>Bird</code>这个构造函数创建一个新的<code>实例</code>：<code>blueBird</code>。如果不使用<code>new</code>操作符来新建对象，那么构造函数里面的<code>this</code>就无法指向新创建的这个对象实例，从而产生不可预见的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Albert"</span>;</span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">"blue"</span>;</span><br><span class="line">  <span class="keyword">this</span>.numLegs = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 构造函数里面的 "this" 总是指向新创建的实例。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> blueBird = <span class="keyword">new</span> Bird();</span><br></pre></td></tr></table></figure>

<p>每个对象不相同，使用传入参数的构造函数可以方便的创建不同的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.numLegs = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> terrier = <span class="keyword">new</span> Dog(<span class="string">"旺财"</span>,<span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a>instance of</h3><p>凡是通过构造函数创建出的新对象，都叫做这个构造函数的<code>实例</code>。JavaScript 提供了一种很简便的方法来验证这个事实，那就是通过<code>instanceof</code>操作符。<code>instanceof</code>允许你将对象与构造函数之间进行比较，根据对象是否由这个构造函数创建的返回<code>true</code>或者<code>false</code>。以下是一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Bird = <span class="function"><span class="keyword">function</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.color = color;</span><br><span class="line"> <span class="keyword">this</span>.numLegs = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> crow = <span class="keyword">new</span> Bird(<span class="string">"Alexis"</span>, <span class="string">"black"</span>);</span><br><span class="line"></span><br><span class="line">crow <span class="keyword">instanceof</span> Bird; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>



<h3 id="使用原型属性来减少重复代码"><a href="#使用原型属性来减少重复代码" class="headerlink" title="使用原型属性来减少重复代码"></a>使用原型属性来减少重复代码</h3><p>所有<code>Bird</code>实例可能会有相同的<code>numLegs</code>值，所以在每一个<code>Bird</code>的实例中本质上都有一个重复的变量<code>numLegs</code>。</p>
<p>当只有两个实例时可能并不是什么问题，但想象一下如果有数百万个实例，这将会产生许许多多重复的变量。</p>
<p>这里有一个更好的方法可以解决上述问题，那就是使用<code>Bird</code>的<code>原型</code>。<code>原型</code>是一个可以在所有<code>Bird</code>实例之间共享的对象。以下是一个在<code>Bird prototype</code>中添加<code>numLegs</code>属性的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype.numLegs = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>现在所有的<code>Bird</code>实例都拥有了共同的<code>numLegs</code>属性值。</p>
<p>由于所有的实例都可以继承<code>原型</code>上的属性，所以可以把<code>原型</code>看作是创建对象的 “配方”。</p>
<p>请注意：<code>duck</code>和<code>canary</code>的<code>原型</code>是<code>Bird</code>构造函数原型<code>Bird.prototype</code>的一部分。JavaScript 中几乎所有的对象都有一个<code>原型</code>属性，这个属性是属于它所在的构造函数的一部分。</p>
<h3 id="迭代所有属性"><a href="#迭代所有属性" class="headerlink" title="迭代所有属性"></a>迭代所有属性</h3><p>两种属性: <code>自身</code>属性和<code>原型</code>属性。<code>自身</code>属性是直接在对象上定义的。而<code>原型</code>属性是定义在<code>prototype</code>上的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">// 自身属性</span></span><br><span class="line">&#125;</span><br><span class="line">Bird.prototype.numLegs = <span class="number">2</span>; <span class="comment">// 原型属性</span></span><br><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Bird(<span class="string">"Donald"</span>);</span><br></pre></td></tr></table></figure>

<p>将<code>duck</code>的<code>自身</code>属性和<code>原型</code>属性分别添加到<code>ownProps</code>数组和<code>prototypeProps</code>数组里面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ownProps = [];</span><br><span class="line"><span class="keyword">let</span> prototypeProps = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> duck) &#123;</span><br><span class="line">  <span class="keyword">if</span>(duck.hasOwnProperty(property)) &#123;</span><br><span class="line">    ownProps.push(property);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prototypeProps.push(property);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ownProps); <span class="comment">// 输出 ["name"]</span></span><br><span class="line"><span class="built_in">console</span>.log(prototypeProps); <span class="comment">// 输出 ["numLegs"]</span></span><br></pre></td></tr></table></figure>



<h3 id="了解构造函数属性"><a href="#了解构造函数属性" class="headerlink" title="了解构造函数属性"></a>了解构造函数属性</h3><p>创建的实例对象<code>duck</code>和<code>beagle</code>都有一个特殊的<code>constructor</code>属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Bird();</span><br><span class="line"><span class="keyword">let</span> beagle = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(duck.constructor === Bird); <span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(beagle.constructor === Dog); <span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>由于<code>constructor</code>属性可以被重写（在下面两节挑战中将会遇到），所以<strong>使用<code>instanceof</code>方法来检查对象的类型会更好</strong>。</p>
<h3 id="将原型更改为新对象"><a href="#将原型更改为新对象" class="headerlink" title="将原型更改为新对象"></a>将原型更改为新对象</h3><p>到目前为止，你已经可以单独给<code>prototype</code>添加属性了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype.numLegs = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这将在添加许多属性的时候变得单调乏味。</p>
<p>一种更有效的方法就是给对象的<code>prototype</code>设置为一个已经包含了属性的新对象。这样一来，所有属性都可以一次性添加进来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype = &#123;</span><br><span class="line"> numLegs: <span class="number">2</span>,</span><br><span class="line"> eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"nom nom nom"</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> describe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<h3 id="更改原型时，记得设置构造函数属性"><a href="#更改原型时，记得设置构造函数属性" class="headerlink" title="更改原型时，记得设置构造函数属性"></a>更改原型时，记得设置构造函数属性</h3><p>手动给新对象重新设置<code>原型</code>对象，会产生一个重要的副作用：删除了<code>constructor</code>属性！</p>
<p>为了解决这个问题，凡是手动给新对象重新设置过原型对象的，都别忘记在原型对象中定义一个<code>constructor</code>属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Bird, // 定义 <span class="keyword">constructor</span> 属性</span><br><span class="line">  numLegs: 2,</span><br><span class="line">  eat: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"nom nom nom"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="了解对象的原型来自哪里"><a href="#了解对象的原型来自哪里" class="headerlink" title="了解对象的原型来自哪里"></a>了解对象的原型来自哪里</h3><p>就像人们从父母那里继承基因一样，对象也可直接从创建它的构造函数那里继承其<code>原型</code>。请看下面的例子：<code>Bird</code>构造函数创建了一个<code>duck</code>对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Bird(<span class="string">"Donald"</span>);</span><br></pre></td></tr></table></figure>

<p><code>duck</code>从<code>Bird</code>构造函数那里继承了它的<code>原型</code>，你可以使用<code>isPrototypeOf</code>方法来验证他们之间的关系：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype.isPrototypeOf(duck);</span><br><span class="line"><span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>



<h3 id="了解原型链"><a href="#了解原型链" class="headerlink" title="了解原型链"></a>了解原型链</h3><p>JavaScript 中所有的对象（除了少数例外）都有自己的<code>原型</code>。而且，对象的<code>原型</code>本身也是一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Bird.prototype; <span class="comment">// =&gt; object</span></span><br></pre></td></tr></table></figure>

<p>正因为<code>原型</code>是一个对象，所以<code>原型</code>对象也有它自己的<code>原型</code>！这样看来的话，<code>Bird.prototype</code>的<code>原型</code>就是<code>Object.prototype</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">Object</span>.prototype.isPrototypeOf(Bird.prototype);</span><br><span class="line"><span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<p>这有什么作用呢？你可能还记得我们在上一个挑战中学到的<code>hasOwnProperty</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Bird(<span class="string">"Donald"</span>);</span><br><span class="line">duck.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p><code>hasOwnProperty</code>是定义在<code>Object.prototype</code>上的一个方法，尽管在<code>Bird.prototype</code>和<code>duck</code>上并没有定义该方法，但是我们依然可以在这两个对象上访问到。这就是一个<code>原型</code>链。</p>
<p>在这个<code>原型</code>链中，<code>Bird</code>构造函数是<code>父级</code>，<code>duck</code>是<code>子级</code>。<code>Object</code>则是<code>Bird</code>构造函数和<code>duck</code>实例共同的<code>父级</code>。</p>
<p><code>Object</code>是 JavaScript 中所有对象的<code>父级</code>，也就是原型链的最顶层。因此，所有对象都可以访问<code>hasOwnProperty</code>方法。</p>
<h3 id="从超类继承行为"><a href="#从超类继承行为" class="headerlink" title="从超类继承行为"></a>从超类继承行为</h3><p>创建一个<code>Animal 超类</code>，用来定义所有动物共有的行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"nom nom nom"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如何给<code>Bird</code>、<code>Dog</code>重写<code>Animal</code>中的方法，而无需重新定义它们。这里我们会用到构造函数的<code>继承</code>特性。</p>
<p>第一步：创建一个<code>超类</code>（或者叫父类）的实例。</p>
<p>你已经学会了一种创建<code>Animal</code>实例的方法，即使用<code>new</code>操作符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br></pre></td></tr></table></figure>

<p>此语法用于<code>继承</code>时会存在一些缺点，这些缺点对于当前我们这个挑战来说太复杂了。相反，我们学习另外一种没有这些缺点的方法来替代<code>new</code>操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = <span class="built_in">Object</span>.create(Animal.prototype);</span><br></pre></td></tr></table></figure>

<p><code>Object.create(obj)</code>创建了一个新对象，并指定了<code>obj</code>作为新对象的<code>原型</code>。回忆一下，我们之前说过<code>原型</code>就像是创建对象的“配方”。如果我们把<code>animal</code>的<code>原型</code>设置为与<code>Animal</code>构造函数的<code>原型</code>一样，那么就相当于让<code>animal</code>这个实例的配方与<code>Animal</code>其他实例的配方一样了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">animal.eat(); <span class="comment">// 输出 "nom nom nom"</span></span><br><span class="line">animal <span class="keyword">instanceof</span> Animal; <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>



<h3 id="将子辈的原型设置为父辈的实例"><a href="#将子辈的原型设置为父辈的实例" class="headerlink" title="将子辈的原型设置为父辈的实例"></a>将子辈的原型设置为父辈的实例</h3><p>我们学习了从<code>超类（或者叫父类） Animal</code>继承其行为的第一个步骤：创建一个<code>Animal</code>的实例。</p>
<p>这一节挑战我们将学习第二个步骤：给<code>子类型（或者子类）</code>设置<code>原型</code>。这样一来，<code>Bird</code>就是<code>Animal</code>的一个实例了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br></pre></td></tr></table></figure>

<p>请记住，<code>原型</code>类似于创建对象的“配方”。从某种意义上来说，<code>Bird</code>对象的配方包含了<code>Animal</code>构造函数的所有关键“成分”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Bird(<span class="string">"Donald"</span>);</span><br><span class="line">duck.eat(); <span class="comment">// 输出 "nom nom nom"</span></span><br></pre></td></tr></table></figure>

<p><code>duck</code>继承了<code>Animal</code>构造函数的所有属性，其中包括了<code>eat</code>方法。</p>
<ul>
<li>相当于java中： person类—student类—李四</li>
</ul>
<h3 id="重置继承的构造函数属性"><a href="#重置继承的构造函数属性" class="headerlink" title="重置继承的构造函数属性"></a>重置继承的构造函数属性</h3><p>当一个对象从另一个对象那里继承了其<code>原型</code>，那它也继承了<code>父类</code>的 constructor 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Bird.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Bird();</span><br><span class="line">duck.constructor <span class="comment">// function Animal()&#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是<code>duck</code>和其他所有<code>Bird</code>的实例都应该表明它们是由<code>Bird</code>创建的，而不是由<code>Animal</code>创建的。为此，你可以手动把<code>Bird</code>的 constructor 属性设置为<code>Bird</code>对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Bird.prototype.constructor = Bird;</span><br><span class="line">duck.constructor <span class="comment">// function Bird()&#123;...&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="继承后添加方法"><a href="#继承后添加方法" class="headerlink" title="继承后添加方法"></a>继承后添加方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"nom nom nom"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Bird.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Bird.prototype.constructor = Bird;</span><br><span class="line"><span class="comment">//添加方法</span></span><br><span class="line">Bird.prototype.fly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I'm flying!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="重写继承的方法"><a href="#重写继承的方法" class="headerlink" title="重写继承的方法"></a>重写继承的方法</h3><p>一个对象可以通过复制另一个对象的<code>原型</code>来继承其属性和行为（或方法）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ChildObject.prototype = <span class="built_in">Object</span>.create(ParentObject.prototype);</span><br></pre></td></tr></table></figure>

<p>然后，<code>ChildObject</code>将自己的方法链接到它的<code>原型</code>中，我们可以像这样访问：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ChildObject.prototype.methodName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还可以重写继承的方法。以同样的方式——通过使用一个与需要重写的方法相同的方法名，向<code>ChildObject.prototype</code>中添加方法。</p>
<p>请看下面的举例：<code>Bird</code>重写了从<code>Animal</code>继承来的<code>eat()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"nom nom nom"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了 Animal 的所有方法</span></span><br><span class="line">Bird.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.eat() 重写了 Animal.eat() 方法</span></span><br><span class="line">Bird.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"peck peck peck"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你有一个实例：<code>let duck = new Bird();</code>，然后你调用了<code>duck.eat()</code>，以下就是 JavaScript 在<code>duck</code>的<code>原型</code>链上寻找方法的过程：</p>
<p>\1. duck =&gt; 这里定义了 eat() 方法吗？没有。</p>
<p>\2. Bird =&gt; 这里定义了 eat() 方法吗？=&gt; 是的。执行它并停止往上搜索。</p>
<p>\3. Animal =&gt; 这里也定义了 eat() 方法，但是 JavaScript 在到达这层原型链之前已停止了搜索。</p>
<p>\4. Object =&gt; JavaScript 在到达这层原型链之前也已经停止了搜索。</p>
<h3 id="使用-Mixin-在不相关对象之间添加共同行为"><a href="#使用-Mixin-在不相关对象之间添加共同行为" class="headerlink" title="使用 Mixin 在不相关对象之间添加共同行为"></a>使用 Mixin 在不相关对象之间添加共同行为</h3><p>对于不相关的对象，更好的方法是使用<code>mixins</code>。<code>mixin</code>允许其他对象使用函数集合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flyMixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.fly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Flying, wooosh!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>flyMixin</code>能接受任何对象，并为其提供<code>fly</code>方法。<code>flyMixin</code>能接受任何对象，并为其提供<code>fly</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bird = &#123;</span><br><span class="line">  name: <span class="string">"Donald"</span>,</span><br><span class="line">  numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> plane = &#123;</span><br><span class="line">  model: <span class="string">"777"</span>,</span><br><span class="line">  numPassengers: <span class="number">524</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">flyMixin(bird);</span><br><span class="line">flyMixin(plane);</span><br><span class="line"><span class="comment">//这里的flyMixin接收了bird和plane对象，然后将fly方法分配给了每一个对象。现在bird和plane都可以飞行了：</span></span><br><span class="line">bird.fly(); <span class="comment">// 输出 "Flying, wooosh!"</span></span><br><span class="line">plane.fly(); <span class="comment">// 输出 "Flying, wooosh!"</span></span><br></pre></td></tr></table></figure>



<h3 id="了解立即调用函数表达（IIFE）"><a href="#了解立即调用函数表达（IIFE）" class="headerlink" title="了解立即调用函数表达（IIFE）"></a>了解立即调用函数表达（IIFE）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Chirp, chirp!"</span>);</span><br><span class="line">&#125;)(); <span class="comment">// 这是一个立即执行的匿名函数表达式</span></span><br><span class="line"><span class="comment">// 立即输出 "Chirp, chirp!"</span></span><br></pre></td></tr></table></figure>

<p>函数声明后立即执行。函数不存放到任何变量当中</p>
<h3 id="使用-IIFE-创建一个模块"><a href="#使用-IIFE-创建一个模块" class="headerlink" title="使用 IIFE 创建一个模块"></a>使用 IIFE 创建一个模块</h3><p>一个<code>自执行函数表达式</code>（<code>IIFE</code>）通常用于将相关功能分组到单个对象或者是<code>模块</code>中。例如，先前的挑战中定义了一个混合类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">glideMixin</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.glide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Gliding on the water"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flyMixin</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.fly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Flying, wooosh!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这些<code>mixins</code>分成以下一个模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> motionModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    glideMixin: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      obj.glide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Gliding on the water"</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    flyMixin: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      obj.fly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Flying, wooosh!"</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) (); <span class="comment">// 末尾的两个括号导致函数被立即调用</span></span><br></pre></td></tr></table></figure>

<p>注意：一个<code>自执行函数表达式</code>（<code>IIFE</code>）返回了一个<code>motionModule</code>对象。返回的这个对象包含了作为对象属性的所有<code>mixin</code>行为。</p>
<p><code>模块</code>模式的优点是，所有的运动行为都可以打包成一个对象，然后由代码的其他部分使用。下面是一个使用它的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">motionModule.glideMixin(duck);</span><br><span class="line">duck.glide();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web前端</category>
        <category>js笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2020/05/07/08%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>函数式编程是一种基于函数计算的软件开发方法。像数学一样，函数在编程中通过输入产生输出。你可以通过多种方式组合基本功能来构建越来越复杂的程序。</p>
<p>函数式编程遵循几个核心原则：</p>
<ul>
<li>独立于程序状态或全局变量，只依赖于传递给它们的参数进行计算</li>
<li>限制更改程序状态，避免更改保存数据的全局对象</li>
<li>对程序的副作用尽量小</li>
</ul>
<p>函数式编程式将程序分成小的、可测试的部分，这里介绍 JavaScript 中函数式编程的基本原则。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>首先，我们将介绍一些术语：</p>
<p><code>Callbacks</code>是被传递到另一个函数中调用的函数。你应该已经在其他函数中看过这个写法，例如在<code>filter</code>中，回调函数告诉 JavaScript 以什么规则过滤数组。</p>
<p>函数就像其他正常值一样，可以赋值给变量、传递给另一个函数，或从其它函数返回，这种函数叫做<code>first class</code>函数。在 JavaScript 中，所有函数都是<code>first class</code>函数。</p>
<p>将函数为参数或返回值的函数叫做<code>higher order</code>函数。</p>
<p>当函数传递给另一个函数或从另一个函数返回时，那些传入或返回的函数可以叫做<code>lambda</code>。</p>
<p><strong><code>Array.splice()</code></strong> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p>
<h3 id="函数式编程注意"><a href="#函数式编程注意" class="headerlink" title="函数式编程注意"></a>函数式编程注意</h3><ul>
<li><p>函数不要改变外部变量（避免避免突变和副作用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> fixedValue = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fixedValue + <span class="number">1</span>; <span class="comment">//这行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newValue = incrementer(); <span class="comment">// 应等于 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fixedValue); <span class="comment">// 应打印 4</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>传递参数，避免外部依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> fixedValue = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementer</span> (<span class="params">value</span>) </span>&#123; <span class="comment">// &lt; ==</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newValue = incrementer(fixedValue); <span class="comment">// 应等于 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fixedValue); <span class="comment">// 应打印 4</span></span><br></pre></td></tr></table></figure>

<p>目前为止，我们已经看到了函数式编程的两个原则：</p>
<p>1) 不要更改变量或对象——创建新变量和对象，并在需要时从函数返回它们。</p>
<p>2) 声明函数参数——函数内的任何计算仅取决于参数，而不取决于任何全局对象或变量。</p>
</li>
</ul>
<p>添加一个元素到数组最后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">arr,bookName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = [...arr];</span><br><span class="line">  newArr.push(bookName);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不能直接返回<code>return newArr.push(bookName);</code></p>
<p>因为这样函数返回值是添加元素后数组的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加末尾元素精简版：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">arr,bookName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...arr,bookName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除特定元素：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr,bookName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.indexOf(bookName)!=<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">e</span>)=&gt;</span>e !== bookName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li>Array.push() 添加元素到数组末尾，返回添加后数组长度</li>
<li>Array.splice() 添加、删除数组元素</li>
<li>Array.filter() 返回满足回调函数的数组元素组成的新数组（即筛除不符合的元素）</li>
<li>Array.map()  返回每个数组元素调用回调函数后的结果组成的新数组，只要回调函数不改变原数组则原数组不变。</li>
<li>Array.slice() 返回一个新数组，不会修改原数组 用slice代替splice可以避免改变原数组</li>
</ul>
<p>使用map方法代替for循环遍历数组是个好方法。</p>
<ul>
<li><p>Array.concat() 返回拼接后的数组</p>
</li>
<li><p>Array.sort() 对数组进行排序，如果该方法时没有参数，将按字母顺序也就是按照字符编码的顺序进行排序，数字排序加参数，a,b 返回a-b则升序，返回a&lt;b则降序。</p>
<ul>
<li><p>sort方法会产生改变原始数组中元素顺序的副作用。换句话说，它会改变数组的位置。避免这种情况的一种方法是先将空数组连接到正在排序的数组上（记住<code>concat</code>返回一个新数组），再用<code>sort</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalArray = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonMutatingSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr=[];</span><br><span class="line">  <span class="keyword">return</span> newArr.concat(arr).sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">nonMutatingSort(globalArray);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>split() 分割字符串成为数组 ，下面是以字符串的符号作为分割点进行分割</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitify</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="regexp">/[\ |\~|\`|\!|\@|\#|\$|\%|\^|\&amp;|\*|\(|\)|\-|\_|\+|\=|\||\\|\[|\]|\&#123;|\&#125;|\;|\:|\"|\'|\,|\&lt;|\.|\&gt;|\/|\?]/g</span>) <span class="comment">//过于复杂</span></span><br><span class="line">    <span class="comment">//应该简化 return str.split(/\W/)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(splitify(<span class="string">"Hello World,I-am code"</span>)); <span class="comment">//["Hello","world","I","am","code"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>join() 将数组组合成字符串 把数组中的所有元素放入一个字符串，并通过指定的分隔符参数进行分隔。</p>
</li>
<li><p>every() 检查每个数组元素是否符合条件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPositive</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val&gt;<span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">checkPositive([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">5</span>]);<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>some() 检查数组中是否有元素符合给定的条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">10</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">220</span>, <span class="number">110</span>, <span class="number">11</span>];</span><br><span class="line">numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> currentValue &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="字符串转换为URL片段"><a href="#字符串转换为URL片段" class="headerlink" title="字符串转换为URL片段"></a>字符串转换为URL片段</h3><p>许多内容管理站点（CMS）为了让添加书签更简单，会将帖子的标题添加到 URL 上。举个例子，如果你写了一篇标题为 “Stop Using Reduce” 的帖子，URL很可能会包含标题字符串的某种形式 (如：”…/stop-using-reduce”)</p>
<p>转换字符串<code>title</code>带有连字符号的 URL 版本。</p>
<p>要求：</p>
<p>输入包含空格和标题大小写单词的字符串</p>
<p>输出字符串，单词之间的空格用连字符(<code>-</code>)替换</p>
<p>输出应该是小写字母</p>
<p>输出不应有任何空格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalTitle = <span class="string">"Winter Is Coming"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlSlug</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title.trim().split(<span class="regexp">/\W+/g</span>).join(<span class="string">"-"</span>).toLowerCase(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> winterComing = urlSlug(globalTitle); <span class="comment">// 为 "winter-is-coming"</span></span><br></pre></td></tr></table></figure>



<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p><code>arity</code>是函数所需的形参的数量。函数<code>Currying</code>意思是把接受多个<code>arity</code>的函数变换成接受单一<code>arity</code>的函数。</p>
<p>换句话说，就是重构函数让它接收一个参数，然后返回接收下一个参数的函数，依此类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Un-curried function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurried</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">curried(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 返回 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x+y+z;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>);<span class="comment">//60</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FCC</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2020/05/10/09jQuery/</url>
    <content><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h2><h3 id="JavaScript库的概念"><a href="#JavaScript库的概念" class="headerlink" title="JavaScript库的概念"></a>JavaScript库的概念</h3><p>JavaScript开发的过程中，处理浏览器的兼容很复杂而且很耗时，于是一些封装了这些操作的库应运而生。这些库还会把一些常用的代码进行封装。</p>
<p>把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js）</p>
<p>常见的JavaScript 库 - jQuery、Prototype、MooTools。其中jQuery是最常用的一个</p>
<p>jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p>
<p>目标：</p>
<ul>
<li><p>掌握编程jQuery的基本使用</p>
<ul>
<li>掌握jQuery插件的使用</li>
<li>能够开发jQuery插件</li>
<li>选择器、属性操作、样式操作、节点操作、动画、事件、插件</li>
</ul>
</li>
</ul>
<h3 id="jQuery的优点好处"><a href="#jQuery的优点好处" class="headerlink" title="jQuery的优点好处"></a>jQuery的优点好处</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery设计的宗旨是&#39;Write Less，Do More&#39;，即倡导写更少的代码，做更多的事情（事半功倍）。它封装JavaScript常用的功能代码，提供一种简便的操作，优化HTML文档操作、事件处理、动画设计和Ajax交互。</span><br><span class="line">jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器。</span><br><span class="line">极大地简化了 JavaScript 编程。</span><br></pre></td></tr></table></figure>



<p>[jQuery官网](http:// jquery.com)</p>
<h3 id="体验jQuery"><a href="#体验jQuery" class="headerlink" title="体验jQuery"></a>体验jQuery</h3><p>使用JavaScript开发过程中，有许多不便之处</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-查找元素的方法太少，麻烦。</span><br><span class="line">-遍历伪数组很麻烦，通常要嵌套一大堆的<span class="keyword">for</span>循环。</span><br><span class="line">-有兼容性问题。</span><br><span class="line">-想要实现简单的动画效果，也很麻烦</span><br><span class="line">-代码冗余。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//页面加载函数</span></span><br><span class="line">    $(<span class="string">'#btn1'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      	<span class="comment">// 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。</span></span><br><span class="line">        $(<span class="string">'div'</span>).show(<span class="number">200</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'#btn2'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'div'</span>).text(<span class="string">'我是内容'</span>); <span class="comment">// 设置文本内容</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>优点总结：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-查找元素的方法多种多样，非常灵活</span><br><span class="line">-拥有隐式迭代特性，因此不再需要手写<span class="keyword">for</span>循环了。</span><br><span class="line">-完全没有兼容性问题。</span><br><span class="line">-实现动画非常简单，而且功能更加的强大。</span><br><span class="line">-代码简单、粗暴。</span><br></pre></td></tr></table></figure>

<h3 id="jQuery中顶级对象"><a href="#jQuery中顶级对象" class="headerlink" title="jQuery中顶级对象"></a>jQuery中顶级对象</h3><p>jQuery中的顶级对象是$或jQuery</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">获取jQuery对象</span><br><span class="line">入口函数</span><br><span class="line">高级功能</span><br></pre></td></tr></table></figure>

<p>注意：jQuery中的$和JQuery关键字本身为同一对象</p>
<h3 id="jQuery中页面加载事件"><a href="#jQuery中页面加载事件" class="headerlink" title="jQuery中页面加载事件"></a>jQuery中页面加载事件</h3><p>使用jQuery的三个步骤：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">引入jQuery文件</span><br><span class="line">入口函数</span><br><span class="line">功能实现</span><br></pre></td></tr></table></figure>

<p>关于jQuery的入口函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>jQuery入口函数与window.onload的对比</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。</span><br><span class="line">jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。<span class="comment">//较快进行加载</span></span><br></pre></td></tr></table></figure>

<h2 id="jQuery对象和DOM对象"><a href="#jQuery对象和DOM对象" class="headerlink" title="jQuery对象和DOM对象"></a>jQuery对象和DOM对象</h2><h3 id="jQuery对象和DOM对象的区别"><a href="#jQuery对象和DOM对象的区别" class="headerlink" title="jQuery对象和DOM对象的区别"></a>jQuery对象和DOM对象的区别</h3><h4 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用原生JavaScript获取的DOM对象</span><br><span class="line">	通过document.getElementById()  反馈的是元素(DOM对象)</span><br><span class="line">通过document.getElementsByTagName()获取到的是什么？</span><br><span class="line">	伪数组(集合)，集合中的每一个对象是DOM对象</span><br></pre></td></tr></table></figure>

<h4 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery对象用$()的方式获取的对象</span><br><span class="line">jQuery对象又可以叫做包装集(包装的DOM对象的集合)</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>jQuery对象不能使用DOM对象的成员，DOM对象不能使用jQuery对象的成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM对象</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">box.text(<span class="string">'hello'</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">box.innerText = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery对象，jQuery对象加前缀$，用以区分DOM对象</span></span><br><span class="line"><span class="keyword">var</span> $box = $(<span class="string">'#box'</span>);</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">$box.innerText = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">$box.text(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="jQuery对象和DOM对象的相互转换"><a href="#jQuery对象和DOM对象的相互转换" class="headerlink" title="jQuery对象和DOM对象的相互转换"></a>jQuery对象和DOM对象的相互转换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery对象转换成DOM对象：   </span><br><span class="line">	jQuery对象.get(索引值); </span><br><span class="line">	jQuery对象[索引值] </span><br><span class="line">    	jQuery对象是包装集(集合)，从集合中取数据可以使用索引的方式</span><br><span class="line">DOM对象转换成jQuery对象：   </span><br><span class="line">	$(DOM对象) 只有这一种方法;</span><br></pre></td></tr></table></figure>



<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。</p>
<p>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。</p>
<p>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。</p>
<h3 id="jQuery基本选择器"><a href="#jQuery基本选择器" class="headerlink" title="jQuery基本选择器"></a>jQuery基本选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>ID选择器</td>
<td>$(‘#id’);</td>
<td align="left">获取指定ID的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(‘.class’);</td>
<td align="left">获取同一类class的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(‘div’);</td>
<td align="left">获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(‘div,p,li’);</td>
<td align="left">使用逗号分隔，只要符合条件之一就可。</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(‘div.redClass’);</td>
<td align="left">获取class为redClass的div元素</td>
</tr>
</tbody></table>
<ul>
<li>总结：跟css的选择器用法一模一样。</li>
</ul>
<h3 id="jQuery层级选择器"><a href="#jQuery层级选择器" class="headerlink" title="jQuery层级选择器"></a>jQuery层级选择器</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>子代选择器</td>
<td>$(‘ul &gt; li’);</td>
<td align="left">使用-号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(‘ul li’);</td>
<td align="left">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>
</tr>
</tbody></table>
<ul>
<li>跟CSS的选择器一模一样。</li>
</ul>
<h3 id="jQuery过滤选择器"><a href="#jQuery过滤选择器" class="headerlink" title="jQuery过滤选择器"></a>jQuery过滤选择器</h3><ul>
<li>这类选择器都带冒号:</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>:eq（index）</td>
<td>$(‘li:eq(2)’).css(‘color’, ‘red’);</td>
<td align="left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td>
</tr>
<tr>
<td>:odd</td>
<td>$(‘li:odd’).css(‘color’, ‘red’);</td>
<td align="left">获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(‘li:even’).css(‘color’, ‘red’);</td>
<td align="left">获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
</tbody></table>
<h3 id="jQuery筛选选择器-方法"><a href="#jQuery筛选选择器-方法" class="headerlink" title="jQuery筛选选择器(方法)"></a>jQuery筛选选择器(方法)</h3><ul>
<li>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>children(selector)</td>
<td>$(‘ul’).children(‘li’)</td>
<td align="left">相当于$(‘ul-li’)，子类选择器</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$(‘ul’).find(‘li’);</td>
<td align="left">相当于$(‘ul li’),后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$(‘#first’).siblings(‘li’);</td>
<td align="left">查找兄弟节点，不包括自己本身。</td>
</tr>
<tr>
<td>parent()</td>
<td>$(‘#first’).parent();</td>
<td align="left">查找父亲</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$(‘li’).eq(2);</td>
<td align="left">相当于$(‘li:eq(2)’),index从0开始</td>
</tr>
<tr>
<td>next()</td>
<td>$(‘li’).next()</td>
<td align="left">找下一个兄弟</td>
</tr>
<tr>
<td>prev()</td>
<td>$(‘li’).prev()</td>
<td align="left">找上一次兄弟</td>
</tr>
</tbody></table>
<h2 id="jQuery操作样式"><a href="#jQuery操作样式" class="headerlink" title="jQuery操作样式"></a>jQuery操作样式</h2><h3 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h3><ul>
<li><p>功能：设置或者修改样式，操作的是style属性。</p>
</li>
<li><p>操作单个样式</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name：需要设置的样式名称</span></span><br><span class="line"><span class="comment">// value：对应的样式值</span></span><br><span class="line">$obj.css(name, value);</span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">$(<span class="string">'#one'</span>).css(<span class="string">'background'</span>,<span class="string">'gray'</span>);<span class="comment">// 将背景色修改为灰色</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置多个样式，用对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一个对象，对象中包含了需要设置的样式名和样式值</span></span><br><span class="line">$obj.css(obj);</span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">$(<span class="string">'#one'</span>).css(&#123;</span><br><span class="line">    <span class="string">'background'</span>:<span class="string">'gray'</span>,</span><br><span class="line">    <span class="string">'width'</span>:<span class="string">'400px'</span>,</span><br><span class="line">    <span class="string">'height'</span>:<span class="string">'200px'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取样式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name:需要获取的样式名称</span></span><br><span class="line">$obj.css(name);</span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line">$(<span class="string">'div'</span>).css(<span class="string">'background-color'</span>);</span><br></pre></td></tr></table></figure>

<p>注意：<strong>获取</strong>样式操作只会返回<strong>第一个</strong>元素对应的样式值。</p>
<p>隐式迭代：</p>
<ol>
<li>设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值</li>
<li>获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</li>
</ol>
<h3 id="class操作"><a href="#class操作" class="headerlink" title="class操作"></a>class操作</h3><ul>
<li>添加样式类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name：需要添加的样式类名，注意参数不要带点.</span></span><br><span class="line">$obj.addClass(name);</span><br><span class="line"><span class="comment">// 例子,给所有的div添加one的样式。</span></span><br><span class="line">$(<span class="string">'div'</span>).addClass(<span class="string">'one'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>移除样式类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name:需要移除的样式类名</span></span><br><span class="line">$obj.removeClass(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// 例子，移除div中one的样式类名</span></span><br><span class="line">$(<span class="string">'div'</span>).removeClass(<span class="string">'one'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否有某个样式类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name:用于判断的样式类名，返回值为true false</span></span><br><span class="line">$obj.hasClass(name)</span><br><span class="line"><span class="comment">// 例子，判断第一个div是否有one的样式类</span></span><br><span class="line">$(<span class="string">'div'</span>).hasClass(<span class="string">'one'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>切换样式类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。</span></span><br><span class="line">$obj.toggleClass(name);</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line">$(<span class="string">'div'</span>).toggleClass(<span class="string">'one'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>tab栏切换案例 </li>
</ul>
<h2 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h2><ul>
<li>jQuery提供了三组基本动画，这些动画都是标准的、有规律的效果，jQuery还提供了自定义动画的功能。</li>
</ul>
<h3 id="三组基本动画"><a href="#三组基本动画" class="headerlink" title="三组基本动画"></a>三组基本动画</h3><ul>
<li>显示(show)与隐藏(hide)是一组动画：</li>
<li>滑入(slideUp)与滑出(slideDown)与切换(slideToggle)，效果与卷帘门类似</li>
<li>淡入(fadeIn)与淡出(fadeOut)与切换(fadeToggle)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$obj.show([speed], [callback]);</span><br><span class="line"><span class="comment">// speed(可选)：动画的执行时间</span></span><br><span class="line">	 <span class="comment">// 1.如果不传，就没有动画效果。如果是slide和fade系列，会默认为normal</span></span><br><span class="line">	 <span class="comment">// 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)</span></span><br><span class="line">     <span class="comment">// 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。</span></span><br><span class="line"><span class="comment">// callback(可选):执行完动画后执行的回调函数</span></span><br><span class="line"></span><br><span class="line">slideDown()/slideUp()/slideToggle();同理</span><br><span class="line">fadeIn()/fadeOut();fadeToggle();同理</span><br></pre></td></tr></table></figure>

<h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><ul>
<li>animate: 自定义动画</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).animate(&#123;params&#125;,[speed],[easing],[callback]);</span><br><span class="line"><span class="comment">// &#123;params&#125;：要执行动画的CSS属性，带数字（必选）</span></span><br><span class="line"><span class="comment">// speed：执行动画时长（可选）</span></span><br><span class="line"><span class="comment">// easing:执行效果，默认为swing（缓动）  可以是linear（匀速）</span></span><br><span class="line"><span class="comment">// callback：动画执行完后立即执行的回调函数（可选）</span></span><br></pre></td></tr></table></figure>

<h3 id="动画队列与停止动画"><a href="#动画队列与停止动画" class="headerlink" title="动画队列与停止动画"></a>动画队列与停止动画</h3><ul>
<li>在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stop方法：停止动画效果</span></span><br><span class="line">stop(clearQueue, jumpToEnd);</span><br><span class="line"><span class="comment">// 第一个参数：是否清除队列</span></span><br><span class="line"><span class="comment">// 第二个参数：是否跳转到最终效果</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="jQuery节点操作"><a href="#jQuery节点操作" class="headerlink" title="jQuery节点操作"></a>jQuery节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $(htmlStr)</span></span><br><span class="line"><span class="comment">// htmlStr：html格式的字符串</span></span><br><span class="line">$(<span class="string">'&lt;span-这是一个span元素&lt;/span-'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">append  appendTo	在被选元素的结尾插入内容</span><br><span class="line">prepend prependTo	在被选元素的开头插入内容</span><br><span class="line">before				在被选元素之前插入内容</span><br><span class="line">after				在被选元素之后插入内容</span><br></pre></td></tr></table></figure>

<h3 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h3><ul>
<li>empty：清空指定节点的所有元素，自身保留(清理门户)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).empty(); <span class="comment">// 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）</span></span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">''</span>);<span class="comment">// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>remove：相比于empty，自身也删除（自杀）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).remove();</span><br></pre></td></tr></table></figure>



<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><ul>
<li>作用：复制匹配的元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制$(selector)所匹配到的元素（深度复制）</span></span><br><span class="line"><span class="comment">// cloneNode(true)</span></span><br><span class="line"><span class="comment">// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。</span></span><br><span class="line">$(selector).clone();</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h2><h3 id="attr操作"><a href="#attr操作" class="headerlink" title="attr操作"></a>attr操作</h3><ul>
<li>设置单个属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：需要设置的属性名</span></span><br><span class="line"><span class="comment">// 第二个参数：对应的属性值</span></span><br><span class="line">$obj.attr(name, value);</span><br><span class="line"><span class="comment">// 用法举例</span></span><br><span class="line">$(<span class="string">'img'</span>).attr(<span class="string">'title'</span>,<span class="string">'哎哟，不错哦'</span>);</span><br><span class="line">$(<span class="string">'img'</span>).attr(<span class="string">'alt'</span>,<span class="string">'哎哟，不错哦'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置多个属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一个对象，包含了需要设置的属性名和属性值</span></span><br><span class="line">$obj.attr(obj)</span><br><span class="line"><span class="comment">// 用法举例</span></span><br><span class="line">$(<span class="string">'img'</span>).attr(&#123;</span><br><span class="line">    title:<span class="string">'哎哟，不错哦'</span>,</span><br><span class="line">    alt:<span class="string">'哎哟，不错哦'</span>,</span><br><span class="line">    style:<span class="string">'opacity:.5'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传需要获取的属性名称，返回对应的属性值</span></span><br><span class="line">$obj.attr(name)</span><br><span class="line"><span class="comment">// 用法举例</span></span><br><span class="line"><span class="keyword">var</span> oTitle = $(<span class="string">'img'</span>).attr(<span class="string">'title'</span>);</span><br><span class="line">alert(oTitle);</span><br></pre></td></tr></table></figure>

<ul>
<li>移除属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：需要移除的属性名，</span></span><br><span class="line">$obj.removeAttr(name);</span><br><span class="line"><span class="comment">// 用法举例</span></span><br><span class="line">$(<span class="string">'img'</span>).removeAttr(<span class="string">'title'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="prop操作"><a href="#prop操作" class="headerlink" title="prop操作"></a>prop操作</h3><ul>
<li>在jQuery1.6之后，对于checked、selected、disabled这类<strong>boolean类型的属性</strong>来说，不能用attr方法，只能用prop方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">$(<span class="string">':checked'</span>).prop(<span class="string">'checked'</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">$(<span class="string">':checked'</span>).prop(<span class="string">'checked'</span>);<span class="comment">// 返回true或者false</span></span><br></pre></td></tr></table></figure>

<h3 id="val-text-html"><a href="#val-text-html" class="headerlink" title="val()/text/()html()"></a>val()/text/()html()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$obj.val()		获取或者设置表单元素的value属性的值</span><br><span class="line">$obj.html() 	对应innerHTML</span><br><span class="line">$obj.text()		对应innerText/textContent，处理了浏览器的兼容性</span><br></pre></td></tr></table></figure>

<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h2 id="jQuery尺寸和位置操作"><a href="#jQuery尺寸和位置操作" class="headerlink" title="jQuery尺寸和位置操作"></a>jQuery尺寸和位置操作</h2><h3 id="width方法与height方法"><a href="#width方法与height方法" class="headerlink" title="width方法与height方法"></a>width方法与height方法</h3><ul>
<li>设置或者获取高度，不包括内边距、边框和外边距</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带参数表示设置高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// 不带参数获取高度</span></span><br><span class="line">$(<span class="string">'img'</span>).height();</span><br></pre></td></tr></table></figure>

<p>获取网页的可视区宽高</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取可视区宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="comment">// 获取可视区高度</span></span><br><span class="line">$(<span class="built_in">window</span>).height();</span><br></pre></td></tr></table></figure>

<h3 id="innerWidth-innerHeight-outerWidth-outerHeight"><a href="#innerWidth-innerHeight-outerWidth-outerHeight" class="headerlink" title="innerWidth/innerHeight/outerWidth/outerHeight"></a>innerWidth/innerHeight/outerWidth/outerHeight</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">innerWidth()/innerHeight()	方法返回元素的宽度/高度（包括内边距）。</span><br><span class="line">outerWidth()/outerHeight()  方法返回元素的宽度/高度（包括内边距和边框）。</span><br><span class="line">outerWidth(<span class="literal">true</span>)/outerHeight(<span class="literal">true</span>)  方法返回元素的宽度/高度（包括内边距、边框和外边距）。</span><br></pre></td></tr></table></figure>

<h3 id="scrollTop与scrollLeft"><a href="#scrollTop与scrollLeft" class="headerlink" title="scrollTop与scrollLeft"></a>scrollTop与scrollLeft</h3><ul>
<li>设置或者获取垂直滚动条的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取页面被卷曲的高度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop();</span><br><span class="line"><span class="comment">// 获取页面被卷曲的宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft();</span><br></pre></td></tr></table></figure>

<p>案例：固定导航栏</p>
<h3 id="offset方法与position方法"><a href="#offset方法与position方法" class="headerlink" title="offset方法与position方法"></a>offset方法与position方法</h3><ul>
<li>offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素(offsetParent)的位置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;</span></span><br><span class="line">$(selector).offset();</span><br><span class="line"><span class="comment">// 获取相对于其最近的有定位的父元素的位置。</span></span><br><span class="line">$(selector).position();</span><br></pre></td></tr></table></figure>



<h2 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="jQuery事件机制"></a>jQuery事件机制</h2><ul>
<li>JavaScript中已经学习过了事件，jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</li>
</ul>
<h3 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a>jQuery事件发展历程(了解)</h3><p>简单事件绑定–bind事件绑定–delegate事件绑定–on事件绑定(推荐)</p>
<ul>
<li>简单事件注册</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click(handler)			单击事件</span><br><span class="line">mouseenter(handler)		鼠标进入事件</span><br><span class="line">mouseleave(handler)		鼠标离开事件</span><br></pre></td></tr></table></figure>

<p>缺点：不能同时注册多个事件</p>
<ul>
<li>bind方式注册事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第二个参数：事件处理程序</span></span><br><span class="line">$(<span class="string">'p'</span>).bind(<span class="string">'click mouseenter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 事件响应方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：不支持动态事件绑定</p>
<ul>
<li>delegate注册委托事件    通过父级元素给自己元素注册事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：selector，要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">'.parentBox'</span>).delegate(<span class="string">'p'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 为 .parentBox下面的所有的p标签绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p>
<ul>
<li>on注册事件</li>
</ul>
<h3 id="on注册事件-重点"><a href="#on注册事件-重点" class="headerlink" title="on注册事件(重点)"></a>on注册事件(重点)</h3><ul>
<li>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。</li>
<li>最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。</li>
</ul>
<p>on注册简单事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span></span><br><span class="line">$(selector).on( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>on注册事件委托</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(selector).on( <span class="string">'click'</span>,<span class="string">'span'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>事件委托原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件委托的原理</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span><br><span class="line">ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(e.target.tagName);</span></span><br><span class="line">  <span class="keyword">if</span> (e.target.tagName.toLowerCase() === <span class="string">'li'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">js事件委托转自凌风之翼</a></p>
<p>on注册事件的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events[,selector][,data],handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过源码查看 bind click delegate on 注册事件的区别</li>
</ul>
<h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><ul>
<li>unbind方式（不用）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).unbind(); <span class="comment">// 解绑所有的事件</span></span><br><span class="line">$(selector).unbind(<span class="string">'click'</span>); <span class="comment">// 解绑指定的事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undelegate方式（不用）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$( selector ).undelegate(); <span class="comment">// 解绑所有的delegate事件</span></span><br><span class="line">$( selector).undelegate( <span class="string">'click'</span> ); <span class="comment">// 解绑所有的click事件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>off方式（推荐）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件</span></span><br><span class="line">$(selector).off();</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有click事件</span></span><br><span class="line">$(selector).off(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector).click(); <span class="comment">// 触发 click事件</span></span><br><span class="line">$(selector).trigger(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// screenX和screenY	对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">// clientX和clientY	距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">// pageX和pageY	距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.keyCode	按下的键盘代码</span></span><br><span class="line"><span class="comment">// event.data	存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.stopPropagation()	阻止事件冒泡行为</span></span><br><span class="line"><span class="comment">// event.preventDefault()	阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">// return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span></span><br></pre></td></tr></table></figure>



<h2 id="jQuery补充知识点"><a href="#jQuery补充知识点" class="headerlink" title="jQuery补充知识点"></a>jQuery补充知识点</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><ul>
<li>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">end(); <span class="comment">// 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</span></span><br></pre></td></tr></table></figure>

<h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><ul>
<li>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</li>
</ul>
<p>作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line"><span class="comment">// 参数二表示当前元素（DOM对象）</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><ul>
<li>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.(让权)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $.noConflict();<span class="comment">// 释放$的控制权,并且把$的能力给了c</span></span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>五角星评分案例</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><ul>
<li>弹出层插件 layer<ul>
<li><a href="https://github.com/sentsin/layer" target="_blank" rel="noopener">layer插件</a></li>
</ul>
</li>
<li>放大镜插件<ul>
<li><a href="http://www.jacklmoore.com/zoom/" target="_blank" rel="noopener">jQuery.zoom</a></li>
</ul>
</li>
<li>轮播图插件<ul>
<li><a href="http://sorgalla.com/jcarousel/" target="_blank" rel="noopener">http://sorgalla.com/jcarousel/</a></li>
<li><a href="https://github.com/OwlCarousel2/OwlCarousel2" target="_blank" rel="noopener">https://github.com/OwlCarousel2/OwlCarousel2</a></li>
</ul>
</li>
<li>图片懒加载插件<ul>
<li><a href="https://github.com/tuupola/jquery_lazyload" target="_blank" rel="noopener">jQuery.lazyload</a></li>
</ul>
</li>
<li>jQueryUI<ul>
<li>常用的2-3个功能演示</li>
</ul>
</li>
<li>查看jQuery插件的源码</li>
</ul>
<h3 id="自己探索插件"><a href="#自己探索插件" class="headerlink" title="自己探索插件"></a>自己探索插件</h3><ul>
<li><a href="https://github.com/aui/artDialog" target="_blank" rel="noopener">artDialog</a></li>
<li><a href="https://github.com/fat/zoom.js" target="_blank" rel="noopener">图片放大</a></li>
<li><a href="http://www.github.com" target="_blank" rel="noopener">github上搜索</a></li>
</ul>
<h2 id="jQuery插件开发"><a href="#jQuery插件开发" class="headerlink" title="jQuery插件开发"></a>jQuery插件开发</h2><ul>
<li>给jQuery增加方法的两种方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.method = fn		静态方法</span><br><span class="line">$.fn.method = fn	实例方法</span><br></pre></td></tr></table></figure>

<ul>
<li>增加一个静态方法，实现两个数的和，插件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  $.add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(jQuery))</span><br><span class="line"></span><br><span class="line">$.add(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>更多插件还要等待自己开发，不开发只用别人的不太好。jQuery基础的使用是必须要掌握的，还要多练习才能更熟练。后续会更新ajax。</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器开发基础</title>
    <url>/2020/05/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="服务端开发基础"><a href="#服务端开发基础" class="headerlink" title="服务端开发基础"></a>服务端开发基础</h1><p>​    至此，可以独立完成网页开发了，具体能完成的东西就是一个一个的网页，而且还能给这个页面加上一些动态的交互。但是这距离成为一个网站还有一些路要走。</p>
<h3 id="还需要学习什么？"><a href="#还需要学习什么？" class="headerlink" title="还需要学习什么？"></a>还需要学习什么？</h3><ul>
<li>搭建WEB服务器（提供网站服务的技术）</li>
<li>HTTP（浏览器与服务端的通讯协议）</li>
<li>服务端开发（动态网页技术）</li>
<li>数据库操作（服务端存储数据方式）</li>
<li>Ajax(浏览器与服务端的数据交互方式)</li>
</ul>
<h3 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h3><p>我们手头上的这些网页，如果想要成为一个网站，首先要完成的第一件事就是有一台公共的 Web 服务器，把这一 系列的页面放到这台 Web 服务器上，让用户可以通过服务器的地址访问到这些网页。</p>
<p>我们手头上的电脑都可以是一台服务器，因为只要能提供服务就可以是一个服务器（提供服务的时候就是服务端，使用服务的时候就是客户端）。 </p>
<p>既然服务器就是安装特定的软件的计算机，那么要让自己的成为 Web 服务器就是要安装一个 Web 服务器软件。</p>
<p>我这里选择介绍的是 <strong>APACHE ====== PHP</strong></p>
<p>搭建服务器的流程按照教程就能成功搭建。</p>
<h3 id="需要掌握的知识"><a href="#需要掌握的知识" class="headerlink" title="需要掌握的知识"></a>需要掌握的知识</h3><ul>
<li><p>IP 地址（Internet Protocol Address）</p>
<ul>
<li>设备在某一个网络中的地址，目前最常见的格式：[0-255].[0-255].[0-255].[0-255] 即为四个 0-255 的数字组成。 </li>
<li>作用就是标识一个网络设备（计算机、手机、电视）在某一个具体的网络当中的地址。</li>
<li>127.0.0.1 是本地回环地址。</li>
</ul>
</li>
<li><p>由于 IP 地址都是没有规律的一些数字组成的，很难被人记住，不利于广泛传播，所以就有人想出来要给 IP 起名字 （别名）。 </p>
<p>记住域名是需要花钱注册的 。</p>
</li>
<li><p>DNS</p>
<ul>
<li>通过宽带运营商提供的服务器解析一个域名背后对应的 IP，这个过程叫做 DNS 寻址，帮你完成 DNS 寻址过程的服务器叫做 DNS 服务器。</li>
<li>hosts文件：先检查本机hosts文件是否包含对当前需要解析的域名的配置。如果有就不会再发起对DNS的请求了</li>
</ul>
</li>
<li><p>端口</p>
<ul>
<li><p>计算机本身是一个封闭的环境，就像是一个大楼，如果需要有数据通信往来，必须有门，这个门在术语中就叫端口，每一个端口都有一个编号，每台计算机只有 65536 个端口（0-65535）。 </p>
</li>
<li><p>一般我们把“占门”的过程叫做监听 。</p>
</li>
<li><p>可以通过在命令行中运行： netstat -an 命令监视本机端口使用情况</p>
<p>http 默认的端口是 80</p>
<p>https 默认的端口是 443</p>
</li>
</ul>
</li>
<li><p>URL</p>
<ul>
<li>URL（Uniform Resource Locator），统一资源定位符，通俗点来说就是表示网络当中某一个网页的完整访问地址，它具有一定的格式</li>
</ul>
</li>
</ul>
<h3 id="请求相应流程"><a href="#请求相应流程" class="headerlink" title="请求相应流程"></a>请求相应流程</h3><p><img src="/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF1.png" alt="image-20200517083919143"></p>
<p>1、用户打开浏览器 </p>
<p>2、地址栏输入我们需要访问的网站网址（URL） </p>
<p>3、浏览器通过 DNS 服务器获取即将访问的网站 IP 地址</p>
<p>4、 浏览器发起一个对这个 IP 的请求 </p>
<p>5、服务端接收到这个请求，进行相应的处理 </p>
<p>6、 服务端将处理完的结果返回给客户端浏览器 </p>
<p>7、浏览器将服务端返回的结果呈现到界面上 </p>
<h3 id="配置APACHE"><a href="#配置APACHE" class="headerlink" title="配置APACHE"></a>配置APACHE</h3><ul>
<li>设置监听端口</li>
<li>设置网站根目录</li>
<li>设置默认文档</li>
<li>设置虚拟主机</li>
</ul>
<h3 id="静态网站和动态网站"><a href="#静态网站和动态网站" class="headerlink" title="静态网站和动态网站"></a>静态网站和动态网站</h3><p>​    至此，我们已经可以把这些静态页面放到服务器上了，客户端也可以通过域名请求这个网站，但是对于我们来说， Apache 能够完成的事情过于简单，无外乎就是找到你请求对应的文件 → 读取文件 → 将文件内容响应给客户端浏览器（文件原封不动的给你）。无法满足让网页内容动起来（随着数据动态变化）的需求。 </p>
<p>​    于是乎，就有人提出了服务端动态网页的概念，这种实现这种概念的技术有很多种：JSP、ASP.NET、PHP、Node等等。 </p>
<p>​    原理：不再将 HTML 固定写死，每次用户请求时，动态执行一段代码，临时生成一个用户想要的 HTML 页面。 </p>
<p>动态网站指的也就是每次请求时服务端动态生成 HTML 返回给用户的这种网站下图为流程：</p>
<p><img src="/images/%E6%9C%8D%E5%8A%A1%E7%AB%AF2.png" alt="image-20200517090326530"></p>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>接触php</title>
    <url>/2020/05/17/%E6%8E%A5%E8%A7%A6php/</url>
    <content><![CDATA[<h1 id="配置-PHP-支持"><a href="#配置-PHP-支持" class="headerlink" title="配置 PHP 支持"></a>配置 PHP 支持</h1><p>Apache 只能处理静态文件请求，对于后缀名为 .php 这种动态文件，它无法执行，所以就当成是一 个静态文件直接返回。</p>
<ul>
<li><p>在服务器上安装 PHP </p>
<ul>
<li>解压 php 到纯英文路径目录中</li>
</ul>
</li>
<li><p>在 Apache 中添加支持 PHP 的配置 </p>
<p> 在 Apache 添加 PHP 处理模块 </p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">LoadModule php7_module 路径</span><br></pre></td></tr></table></figure>

<pre><code>在 &lt;IfModule mime_module&gt; 节点中添加 .php 扩展名解析支持 </code></pre><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">AddType application/x‐httpd‐php .php</span><br></pre></td></tr></table></figure>

<p>​        默认文档配置节点 <IfModule dir_module> 中添加 index.php，默认文档指的是在访问一个目录而不是具体文件名时，默认执行的文件名</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;IfModule dir_module&gt; </span><br><span class="line">    DirectoryIndex index.html index.php </span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启Apache</li>
</ul>
<h3 id="Apache与PHP"><a href="#Apache与PHP" class="headerlink" title="Apache与PHP"></a>Apache与PHP</h3><p>我们不能把他们混在一起，他们两者各自有各自负责的领域，各自的职责，但是我们在使用 PHP 做动态网站开发时，两者就会产生联系，具体如下：</p>
<p><img src="/images/php1.png" alt=""></p>
<blockquote>
<p>你可以理解为：Apache 是一家没有太多能力的公司，只能处理一些简单的业务（静态网站），但是心很大想 做更多的事（动态网站），所以就想到了外包，所有额外的业务都需要外包给其他程序，而 PHP 就是理解为 一个专门能够处理 php 业务的外包公司</p>
</blockquote>
<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>类似于在 HTML 中使用 JavaScript，但是不同的是 JavaScript 运行在客户端，而 PHP 运行在服务端。 只有处于 PHP 标记内部的代码才是 PHP 代码，PHP 标记以外都原封不动。</p>
<ol>
<li><p>PHP 标记</p>
<ul>
<li>&lt;?php  进入PHP模式</li>
<li>?&gt; 退出PHP模式</li>
<li>类似于在 HTML 中使用 JavaScript，但是不同的是 JavaScript 运行在客户端，而 PHP 运行在服务端。 只有处于 PHP 标记内部的代码才是 PHP 代码，PHP 标记以外都原封不动。</li>
<li>省略结束标记：当PHP处于文件末尾时，省略结束标记，方式出现额外空行。</li>
</ul>
</li>
<li><p>输出内容格式</p>
<ul>
<li><p>echo </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// echo 是 PHP 中的一个特殊的“指令”，</span></span><br><span class="line"><span class="comment">// 不一定需要像函数那样通过 `()` 去使用 </span></span><br><span class="line"><span class="comment">// 注意：echo 后面紧跟着一个空格 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'hello php'</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">'hello'</span>, <span class="string">'world'</span>;  <span class="comment">//可以输出多个参数</span></span><br><span class="line"><span class="comment">// =&gt; `helloworld`</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p>print</p>
<p> print 与 echo 唯一区别就是只能有一个参数 print ‘hello’; </p>
</li>
<li><p>var_dump</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// var_dump 是一个函数，必须跟上 () 调用 </span></span><br><span class="line"><span class="comment">// 可以将数据以及数据的类型打印为特定格式 var_dump('hello php'); </span></span><br><span class="line"><span class="comment">// =&gt; 'string(9) "hello php"'</span></span><br></pre></td></tr></table></figure>

<p>还有一些输出函数，先不说。。</p>
</li>
</ul>
<ol start="3">
<li><p>与HTML混编</p>
<ul>
<li><p>普通嵌入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'hello'</span>; <span class="meta">?&gt;</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>语句混编</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span> ($age &gt; <span class="number">18</span>): <span class="meta">?&gt;</span>   </span><br><span class="line">	&lt;p&gt;成年人&lt;/p&gt; </span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">else</span>: <span class="meta">?&gt;</span> </span><br><span class="line"> 	 &lt;p&gt;小朋友&lt;/p&gt; </span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">endif</span> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>单行====&gt;  // 或 #</li>
<li>多行====&gt; /*  内容   */</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>和其他编程语言大同小异</li>
</ul>
</li>
<li><p>变量</p>
<ul>
<li>PHP 中申明一个变量是用一个美元符号后面跟变量名来表示。</li>
<li>变量名同样是区分大小写的。</li>
<li>PHP 中变量无需声明类型，变量的类型根据值的类型来推断。</li>
</ul>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$foo; <span class="comment">// 申明一个变量，变量名为 `foo`，未对其进行赋值 </span></span><br><span class="line">$bar = <span class="string">'baz'</span>; <span class="comment">// 申明一个变量，将一个值为 `baz` 的字符串赋值给它 </span></span><br><span class="line"><span class="keyword">echo</span> $foo; <span class="comment">// 输出一个变量名为 `foo` 的变量 </span></span><br><span class="line">fn($bar); <span class="comment">// 将一个变量名为 `foo` 的变量作为 `fn` 的实参传递</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>超全局变量</p>
<p>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。</p>
<p>这些超全局变量是：</p>
<ul>
<li>$GLOBALS — 引用全局作用域中可用的全部变量</li>
<li>$_SERVER — 获取服务端相关信息 </li>
<li>$_REQUEST — 获取提交参数 </li>
<li>$_POST — 获取 POST 提交参数 </li>
<li>$_GET — 获取 GET 提交参数 </li>
<li>$_FILES — 获取上传文件 </li>
<li>$_ENV — 操作环境变量 </li>
<li>$_COOKIE — 操作 Cookie</li>
<li>$_SESSION — 操作 Session</li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li><p>定义</p>
</li>
<li><pre><code class="php"><span class="meta">&lt;?php</span> 
<span class="comment">// 定义常量使用的是内置的 `define` 函数 </span>
<span class="comment">// 第一个参数是常量的名称，建议采用全大写字母命名，多个单词下划线分隔 </span>
<span class="comment">// 第二个参数是常量中存放的数据，可以是任意类型 </span>
<span class="comment">// 第三个参数是常量名称是否区不分大小写，默认 false 区分大小写 </span>
define(<span class="string">'SYSTEM_NAME'</span>, <span class="string">'大百度'</span>); 
define(<span class="string">'SYSTEM_ENABLE'</span>, <span class="keyword">true</span>);
&lt;!--￼<span class="number">8</span>--&gt;


</code></pre>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>服务端笔记</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 基础</title>
    <url>/2020/05/18/Node%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Node-js-基础"><a href="#Node-js-基础" class="headerlink" title="Node.js 基础"></a>Node.js 基础</h1><h4 id="1-1-为什么学习Node-js-？"><a href="#1-1-为什么学习Node-js-？" class="headerlink" title="1.1 为什么学习Node.js ？"></a>1.1 为什么学习Node.js ？</h4><ul>
<li>最简单最直接的一点，岗位需要这种技能</li>
<li>能够和后端程序员更加紧密的配合</li>
<li>网站业务逻辑前置，学习前端技术需要后端技术支撑</li>
<li>扩宽知识视野，能够站在更高的角度审视整个项目</li>
</ul>
<h4 id="1-2-服务器端需要做的事"><a href="#1-2-服务器端需要做的事" class="headerlink" title="1.2 服务器端需要做的事"></a>1.2 服务器端需要做的事</h4><ul>
<li>实现网站的业务逻辑</li>
<li>实现数据的增删改查</li>
</ul>
<h4 id="1-3-Node的好处"><a href="#1-3-Node的好处" class="headerlink" title="1.3 Node的好处"></a>1.3 Node的好处</h4><ul>
<li><p>使用JavaScript语法开发后端应用</p>
</li>
<li><p>一些公司要求前端工程师掌握Node开发</p>
</li>
<li><p>生态系统活跃，有大量开源库可以使用</p>
</li>
<li><p>前端开发工具大多基于Node开发</p>
</li>
</ul>
<h4 id="1-4-Node是什么？"><a href="#1-4-Node是什么？" class="headerlink" title="1.4 Node是什么？"></a>1.4 Node是什么？</h4><blockquote>
<p> <strong>Node是一个基于Chrome V8引擎的JavaScript代码运行环境。</strong></p>
</blockquote>
<h3 id="2-Node下载安装"><a href="#2-Node下载安装" class="headerlink" title="2. Node下载安装"></a>2. Node下载安装</h3><ol>
<li><p>官网下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">链接</a></p>
</li>
<li><p>将Node安装目录添加到环境变量中</p>
</li>
</ol>
<h3 id="3-Node基础"><a href="#3-Node基础" class="headerlink" title="3. Node基础"></a>3. Node基础</h3><p>在Node环境下执行代码，使用Node命令执行后缀为.js的文件即可</p>
<p><img src="/images/node1.PNG" alt=""></p>
<h4 id="3-1-Node-js全局对象global"><a href="#3-1-Node-js全局对象global" class="headerlink" title="3.1 Node.js全局对象global"></a>3.1 Node.js全局对象global</h4><p>在浏览器中全局对象是window，在Node中全局对象是global。与js的全局对象名字作用一致</p>
<ul>
<li>console.log()      在控制台中输出</li>
<li>setTimeout()      设置超时定时器</li>
<li>clearTimeout()   清除超时时定时器</li>
<li>setInterval()       设置间歇定时器</li>
<li>clearInterval()    清除间歇定时器</li>
</ul>
<h3 id="4-Node-js-的模块化开发"><a href="#4-Node-js-的模块化开发" class="headerlink" title="4. Node.js 的模块化开发"></a>4. Node.js 的模块化开发</h3><h4 id="4-1-JavaScript-开发弊端"><a href="#4-1-JavaScript-开发弊端" class="headerlink" title="4.1 JavaScript 开发弊端"></a>4.1 JavaScript 开发弊端</h4><p>JavaScript在使用时存在两大问题，<strong>文件依赖</strong>和<strong>命名冲突</strong>。</p>
<h4 id="4-2-软件中的模块化开发"><a href="#4-2-软件中的模块化开发" class="headerlink" title="4.2 软件中的模块化开发"></a>4.2 软件中的模块化开发</h4><p>一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。</p>
<p><img src="/images/node%E6%A8%A1%E5%9D%97%E5%8C%96.PNG" alt="">))</p>
<h4 id="4-3-Node-js的模块化开发"><a href="#4-3-Node-js的模块化开发" class="headerlink" title="4.3 Node.js的模块化开发"></a>4.3 Node.js的模块化开发</h4><ul>
<li>Node.js规定，一个js文件就是一个模块，模块内部的函数、变量默认情况下在外部是无法得到的，被隔离的。</li>
<li>模块内部可以使用<strong>exports</strong>对象导出成员，使用<strong>require</strong> 导入其他模块。</li>
</ul>
<p>模块成员导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"> <span class="comment">// 在模块内部定义变量</span></span><br><span class="line"><span class="keyword">let</span> version = <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// 在模块内部定义方法</span></span><br><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`您好, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 向模块外部导出数据 </span></span><br><span class="line">exports.version = version;</span><br><span class="line">exports.sayHi = sayHi;</span><br></pre></td></tr></table></figure>

<p>模块成员导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// b.js</span></span><br><span class="line"> <span class="comment">// 在b.js模块中导入模块a</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"> <span class="comment">// 输出b模块中的version变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a.version);</span><br><span class="line"> <span class="comment">// 调用b模块中的sayHi方法 并输出其返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi(<span class="string">'大兄弟'</span>));</span><br></pre></td></tr></table></figure>

<p>其中，导入模块时，后缀名可以省略 （省略.js）</p>
<h4 id="4-4模块成员的另一种导出方式"><a href="#4-4模块成员的另一种导出方式" class="headerlink" title="4.4模块成员的另一种导出方式"></a>4.4模块成员的另一种导出方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.version = version;</span><br><span class="line"><span class="built_in">module</span>.exports.sayHi = sayHi;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>exports是module.exports的别名(地址引用关系)，导出对象最终以module.exports为准,module.exports才是老大哥了。</p>
</blockquote>
<h3 id="5-系统模块"><a href="#5-系统模块" class="headerlink" title="5. 系统模块"></a>5. 系统模块</h3><p>Node运行环境提供的API. 因为这些API都是以模块化的方式进行开发的, 所以称Node运行环境提供的API为系统模块</p>
<h4 id="5-1-系统模块fs-文件操作"><a href="#5-1-系统模块fs-文件操作" class="headerlink" title="5.1 系统模块fs 文件操作"></a>5.1 系统模块fs 文件操作</h4><p>读取内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入系统模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">fs.readFile(<span class="string">'文件路径/名称'</span>编码类型<span class="string">'],callback)</span></span><br></pre></td></tr></table></figure>

<p>写入内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要写入的内容</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">'我是内容，要写入'</span></span><br><span class="line">fs.writeFile(<span class="string">'文件路径'</span>,content,error=&gt;&#123;</span><br><span class="line">	<span class="keyword">if</span>(err!=<span class="literal">null</span>)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'写入成功'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-路径操作path"><a href="#5-2-路径操作path" class="headerlink" title="5.2 路径操作path"></a>5.2 路径操作path</h4><p>路径拼接：从url解析出来的路径不一定是服务器中实际上的物理路径，这里往往需要进行路径拼接才能得到实际地址，获取正确的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">//获取当前文件所在的物理路径</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"><span class="keyword">let</span> realPath = path.join(__dirname,<span class="string">'fsRead.js'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在读取文件或者设置文件路径时都会选择绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录</p>
</blockquote>
<h3 id="6-第三方模块"><a href="#6-第三方模块" class="headerlink" title="6. 第三方模块"></a>6. 第三方模块</h3><p>别人写好的、具有特定f功能的、我们能直接使用的模块即第三方模块，又名包。</p>
<p>第三方模块的两种存在方式：</p>
<ul>
<li>以js文件的形式存在，提供实现项目具体功能的API接口。</li>
<li>以命令行工具形式存在，辅助项目开发</li>
</ul>
<p><code>npmjs.com</code>：第三方模块的存储和分发仓库</p>
<h4 id="6-1-获取第三方模块"><a href="#6-1-获取第三方模块" class="headerlink" title="6.1 获取第三方模块"></a>6.1 获取第三方模块</h4><p><code>npm (node package manager)</code>： node的第三方模块管理工具</p>
<p>安装：<code>npm install 模块名</code></p>
<p>卸载：<code>npm uninstall 模块名</code></p>
<p>全局安装和本地安装：</p>
<ul>
<li>命令行工具：全局安装  后面加 <code>-g</code></li>
<li>库文件：本地安装</li>
</ul>
<h4 id="6-2-Gulp模块"><a href="#6-2-Gulp模块" class="headerlink" title="6.2 Gulp模块"></a>6.2 Gulp模块</h4><p>它是基于node平台开发的前端构建工具</p>
<p>它可以：</p>
<ul>
<li>项目上线，HTML、CSS、JS文件压缩合并</li>
<li>语法转换（es6、less …）</li>
<li>公共文件抽离</li>
<li>修改文件浏览器自动刷新</li>
</ul>
<h6 id="gulp的使用"><a href="#gulp的使用" class="headerlink" title="gulp的使用"></a>gulp的使用</h6><ul>
<li>使用<code>npm install gulp</code>下载gulp库文件</li>
<li>在项目根目录下建立<code>gulpfile.js</code>文件</li>
<li>重构项目的文件夹结构 <code>src</code>目录放置源代码文件，<code>dist</code>目录放置构建后的文件</li>
<li>在<code>gulpfile.js</code>文件中编写任务</li>
<li>在命令行工具中执行gulp任务</li>
</ul>
<p>gulp插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gulp-htmlmin ：html文件压缩</span><br><span class="line">gulp-csso ：压缩css</span><br><span class="line">gulp-babel ：JavaScript语法转化</span><br><span class="line">gulp-less: less语法转化</span><br><span class="line">gulp-uglify ：压缩混淆JavaScript</span><br><span class="line">gulp-file-include 公共文件包含</span><br><span class="line">browsersync 浏览器实时同步</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入gulp模块</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="comment">//引入htmlmin模块</span></span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="comment">//引入fileinclude模块,用于抽离公共部分的代码</span></span><br><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">'gulp-file-include'</span>);</span><br><span class="line"><span class="comment">//引入less文件转换成css文件的模块gulp-less</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"><span class="comment">//引入压缩css文件的模块gulp-csso</span></span><br><span class="line"><span class="keyword">const</span> csso = <span class="built_in">require</span>(<span class="string">'gulp-csso'</span>);</span><br><span class="line"><span class="comment">//引入转换js文件的模块gulp-babel</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="comment">//引入压缩js文件的模块gulp-uglify</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="comment">//gulp使用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//gulp.task 新建任务</span></span><br><span class="line"><span class="comment">//任务名   函数</span></span><br><span class="line">gulp.task(<span class="string">'first'</span>,done=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello,gulp"</span>);</span><br><span class="line">    gulp.src(<span class="string">'./src/css/base.css'</span>)</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</span><br><span class="line">    done();<span class="comment">//告诉gulp已经完成了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//html任务 1.将html代码压缩，2、将html中的公共代码抽离</span></span><br><span class="line">gulp.task(<span class="string">'htmlmin'</span>,done=&gt;&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/*.html'</span>)</span><br><span class="line">        .pipe(fileinclude()) <span class="comment">//文件导入include</span></span><br><span class="line">        .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))<span class="comment">//压缩代码</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/'</span>));</span><br><span class="line">        done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//css任务： 1、将less文件转换成css文件 2、将css文件压缩</span></span><br><span class="line">gulp.task(<span class="string">'cssmin'</span>,done=&gt;&#123;</span><br><span class="line">    gulp.src([<span class="string">'./src/css/*.less'</span>,<span class="string">'./src/css/*.css'</span>])</span><br><span class="line">        .pipe(less())<span class="comment">//less转换成css          </span></span><br><span class="line">        .pipe(csso())<span class="comment">//css压缩</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/css/'</span>))      </span><br><span class="line">        done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//js任务： 1、es6代码装换 2、代码压缩</span></span><br><span class="line">gulp.task(<span class="string">'jsmin'</span>,done=&gt;&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/js/*.js'</span>)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [<span class="string">'@babel/env'</span>] <span class="comment">//根据当前环境支持的类型进行转换</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/js/'</span>));</span><br><span class="line">        done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制任务</span></span><br><span class="line">gulp.task(<span class="string">'copy'</span>,done=&gt;&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/images/*'</span>)<span class="comment">//复制images</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/images/'</span>))</span><br><span class="line"></span><br><span class="line">    gulp.src(<span class="string">'./src/lib/*'</span>)<span class="comment">//复制lib</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/lib'</span>))</span><br><span class="line">        done();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将任务连起来，一个命令即可执行</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>,gulp.series(<span class="string">'htmlmin'</span>,<span class="string">'cssmin'</span>,<span class="string">'jsmin'</span>,<span class="string">'copy'</span>));</span><br></pre></td></tr></table></figure>



<h3 id="7-package-json文件"><a href="#7-package-json文件" class="headerlink" title="7. package.json文件"></a>7. package.json文件</h3><p> 作用：</p>
<blockquote>
<p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些<strong>第三方模块</strong>等。<br>使用npm init -y命令生成。</p>
</blockquote>
<p><strong>项目依赖</strong></p>
<p>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖<br>使用<code>npm install 包名</code>命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  "mime": "^2.4.5"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开发依赖</strong></p>
<p>在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖<br>使用<code>npm install 包名 --save-dev</code>命令将包添加到package.json文件的devDependencies字段中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "gulp": "^4.0.2"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-package-lock-json"><a href="#8-package-lock-json" class="headerlink" title="8. package-lock.json"></a>8. package-lock.json</h3><p>作用：</p>
<blockquote>
<p>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题,可以加快下载速度</p>
</blockquote>
]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端笔记</tag>
        <tag>Node</tag>
      </tags>
  </entry>
</search>
